{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Technical Specifications SE EUDIW","text":"<p>This page contains technical documentation for the Swedish EUDIW project.</p>"},{"location":"R2PS-protocol/","title":"Remote PAKE-Protected Services Protocol (R2PS)","text":""},{"location":"R2PS-protocol/#abstract","title":"Abstract","text":"<p>This specification defines the Remote PAKE-Protected Services protocol (R2PS) as a generic protocol for service data exchange between a client and multiple services in a backend services infrastructure. R2PS provides end-to-end encryption of service data from the client all the way to the backend service and allows separate backend services to exchange data with the client under separate security contexts.</p>"},{"location":"R2PS-protocol/#1-introduction","title":"1 Introduction","text":"<p>The R2PS protocol is designed to allow less capable clients, such as mobile phone apps, to provide critical services for the client in a secure server environment.</p> <p>This protocol is generic and can be used to support any client application, but it is developed in particular to support wallet applications that need to meet the EU eIDAS regulation. The primary challenge for eIDAS wallets is that the security requirements imposed on eIDAS require the wallet to operate an HSM protected key. As many mobile phones do not offer this capability, this protocol offers an alternative that provides such HSM capabilities via a remote server over a secure protocol.</p> <p>However, a remote server is also usable for many other purposes such as</p> <ul> <li>Common data storage to enable the user to operate the same wallet instance from multiple devices</li> <li>Private client data storage</li> <li>Audit logging</li> </ul> <p>End-to-end encryption offered by R2PS is designed to meet the following security requirements:</p> <ul> <li>Encryption of service data uses a session key that provides forward secrecy.</li> <li>Cryptographic separation of keys used to encrypt data under different security contexts.</li> </ul>"},{"location":"R2PS-protocol/#11-encryption-modes","title":"1.1 Encryption modes","text":"<p>Encryption of service data supports two defined modes:</p> <ul> <li>Device-authenticated encryption</li> <li>User-authenticated encryption</li> </ul> <p>Device-authenticated encryption</p> <p>Device-authenticated encryption uses ephemeral-static Diffie-Hellman JWE encryption as defined in RFC 7518.  The client encrypts to the server public key, and the server encrypts to the client public context key.</p> <p>This encryption mode is used for services that need to be exchanged before a user-authenticated encryption key has been negotiated. This encryption mode is, for example, used for PAKE service exchanges to negotiate encryption keys bound to the user's PIN for user-authenticated encryption. </p> <p>User-authenticated encryption</p> <p>User-authenticated encryption uses an encryption key negotiated through a PAKE key exchange that binds the encryption key to the user's PIN. Depending on the selected PAKE protocol, the encryption key SHOULD also be bound to the client context key as well as the server key pair. The RECOMMENDED configuration is to use OPAQUE in combination with PIN hardening (See 3.3.2).</p>"},{"location":"R2PS-protocol/#2-basic-structure","title":"2 Basic structure","text":"<p>R2PS defines a generic and stateless request/response protocol for client-initiated requests to a server infrastructure. Each service request and response includes encrypted service data defined by a service_type identifier, where the format of the service data is defined by the service_type identifier.</p> <p>A service request also defines a context identifier that specifies the security context for the service data. This allows the server infrastructure to forward the encrypted data to the backend server that handles this context. The backend server that handles a particular context is typically responsible for negotiating the context session key, decrypting the request service data, and encrypting response service data back to the client, providing a true application level end-to-end protected exchange.</p> <p>The following image illustrates a sample deployment of R2PS where HSM operations are dispatched to a separate HSM server under a unique security context.</p> <pre><code>                                         User\n                                          |                             \n                                     PIN  |                             \n                                          v                             \n                             +---------------------------+\n                             |          Client           |\n                             |                           |\n                             |  Context Key Pairs 1..n   |\n                             +------------+--------------+\n                                          ^\n                        R2PS              |\n                        Request/Response  |\n                                          v\n                        +-----------------+-----------------+\n                        |      Common Server (BFF)          |\n                        |  +----------------------------+   |   context=\"hsm\"\n                        |  |        Dispatcher          |--------+\n                        |  +----------------------------+   |    |\n                        |        |               |          |    |\n                        |        V               V          |    |\n                        | +------------+  +---------------+ |    |\n                        | |  Context   |  |Service Handler| |    |\n                        | |PAKE handler|  +---------------+ |    |\n                        | +------------+  +---------------+ |    |\n                        |                 |Service Handler| |    |\n                        |                 +---------------+ |    |\n                        +----------+----------+-------------+    |\n                                                                 V\n                                          +-----------------+-----------------+\n                                          |     Backend Server (HSM)          |\n                                          |  +----------------------------+   |\n                                          |  |        Dispatcher          |   |\n                                          |  +----------------------------+   |\n                                          |        |               |          |\n                                          |        V               V          |\n                                          | +------------+  +---------------+ |\n                                          | |  Context   |  |Service Handler| |\n                                          | |PAKE handler|  +---------------+ |\n                  +---------------+       | +------------+  +---------------+ |\n                  |      HSM      |&lt;-----------------------&gt;|Service Handler| |\n                  +---------------+       |                 +---------------+ |\n                                          +----------+----------+-------------+\n</code></pre> <p>Service data under a common security context is dispatched to a suitable service handler for processing based on the service_type identifier.</p> <p>The Context PAKE (Password Authenticated Key Exchange) handler is a special case service handler that is responsible for authenticating the client and its user and for negotiating a shared session key with the client.</p> <p>The illustration above is only meant to provide guidance and shows one way to utilize the capabilities of the protocol. It remains an important choice for how this is deployed in practice.</p>"},{"location":"R2PS-protocol/#3-protocol","title":"3 Protocol","text":"<p>Generic protocol endpoint requirements:</p> <ul> <li>HTTP POST MUST be supported with Service request bytes as the HTTP request body.</li> <li>A successful service responses SHALL be retuned with an HTTP status code of 200. On failure of handling the service request, the server SHALL respond with an error response as defined below.</li> </ul>"},{"location":"R2PS-protocol/#31-service-request-and-response","title":"3.1 Service Request and Response","text":"<p>Service requests and service responses have the form of a JWS [RFC7515] represented by its compact serialization format. The Payload of the JWS is a JSON object with the defined parameters specified in the following sections.</p>"},{"location":"R2PS-protocol/#311-common-requestresponse-parameters","title":"3.1.1 Common request/response parameters","text":"<p>The following parameters MUST be present in both service requests and service responses:</p> <ul> <li><code>ver</code> : (string) - Holds a version identifier of this protocol. This version of the protocol SHALL be defined by the string \"1.0\"</li> <li><code>nonce</code> : (byte array) - A random value that MUST be present in the request and returned in the service response</li> <li><code>iat</code> : (integer) - Seconds since epoch when this service request or response was created</li> <li><code>enc</code> : (string) - having the value <code>user</code>or <code>device</code>, where <code>user</code> indicates service data encryption using a PAKE negotiated session key and <code>device</code> indicates service data encryption to a device-bound key.</li> <li><code>data</code> : (byte array) - Service data byte array. This is the bytes of JWE encrypted data using compact serialization.</li> </ul>"},{"location":"R2PS-protocol/#312-service-request","title":"3.1.2 Service Request","text":"<p>The following parameters MUST be present in service requests in addition to the common request/response parameters:</p> <ul> <li><code>client_id</code> : (string) - The identifier of the client entity. A client entity may reside on multiple devices using different keys on different devices.</li> <li><code>kid</code> : (string) - Key identifier for the context key used by the client entity on the current device.</li> <li><code>context</code> : (string) -  The security context under which the request is made</li> <li><code>type</code> : (string) -  An identifier of the type of service that is requested. The service type determines the structure of the data byte array</li> <li><code>pake_session_id</code> (string) - An identifier of the pake authenticated session to be used to support encryption of service data. Each pake session holds a unique negotiated session key used to encrypt data.</li> </ul> <p>These parameters collectively give the server the necessary information to;</p> <ul> <li>route the request to the appropriate resource, </li> <li>retrieve the correct signature validation key and data encryption key, and; </li> <li>correctly parse the service request data.</li> </ul> <p>This is achieved through the provided parameters in the following logical process:</p> <ul> <li>The <code>context</code> identifier is used to route the request to the backend resource that holds the keys necessary to process requests under this security context. E.g. a remote HSM server under a HSM security context.</li> <li>The <code>client_id</code> is used to retrieve all records associated with a client \"account\" in the server infrastructure, such as an EU wallet instance.</li> <li>The <code>kid</code> identifies the client public key used to establish a PAKE session for the current security context. This is by default also the key used to validate the signature on the service request, unless the JWS header specifies another <code>kid</code>, or validation key.</li> <li>the <code>pake_session_id</code> is used to locate an active session holding a session key used to extract the session key used to decrypt service request data.</li> <li>The <code>type</code> identifies what data that should be obtained as service data after decryption.</li> </ul> <p>A service request SHOULD include the <code>typ</code> header parameter having the value <code>JOSE</code> (TBD consider a specific defined typ parameter).</p> <p>A service request MUST contain required JWS header parameters as defined in [RFC7515]</p>"},{"location":"R2PS-protocol/#313-service-response","title":"3.1.3 Service Response","text":"<p>A service response is bound to the service request by providing an identical nonce value. The server MUST ensure that the nonce value from the service request is non-null and provides at least 64 bits of entropy.</p> <p>A service response MUST include all the common request/response parameters defined above.</p> <p>A service response MUST NOT include any of the additional service request parameters. These values are already known by the client and bound to the request via the signed nonce.</p> <p>A service response SHOULD include the <code>typ</code> header parameter having the value <code>JOSE</code> (TBD consider a specific defined typ parameter).</p> <p>A service request MUST contain required JWS header parameters as defined in [RFC7515]</p>"},{"location":"R2PS-protocol/#32-error-response","title":"3.2 Error response","text":"<p>If a server for any reason fails to successfully process and respond to a service request, it MUST respond with an appropriate HTTP error code and a structured error response.</p> <p>The following error response codes are defined:</p> Response code HTTP response code ILLEGAL_REQUEST_DATA 400 UNAUTHORIZED 401 ACCESS_DENIED 403 ILLEGAL_STATE 409 UNSUPPORTED_REQUEST_TYPE 415 SERVER_ERROR 500 TRY_LATER 503 <p>The HTTP body MUST return a JSON data string (UTF-8 encoded) with the following parameters:</p> <ul> <li><code>error_code</code> : (string) - The error code from the table above</li> <li><code>error_message</code>: (string) - A human readable message with details of the cause of the error response</li> </ul> <p>Example error response JSON: <pre><code>{\n  \"error_code\" : \"ACCESS_DENIED\",\n  \"error_message\" : \"The service type 'hsm_ecdsa' under context 'test' is not supported by any handler\"\n}\n</code></pre></p>"},{"location":"R2PS-protocol/#33-pake-exchanges","title":"3.3 PAKE exchanges","text":"<p>PAKE (Password authenticated key exchange) is used to negotiate session keys based on the client's context key and the client's PIN.</p> <p>PAKE processing is handled through the following service type exchanges:</p> <ul> <li><code>pin_registration</code> : Identifies a service exchange where the client registers a new PIN code for a particular security context</li> <li><code>pin_change</code> : Identifies a service exchange where the client is changing an old PIN to a new PIN</li> <li><code>authenticate</code> : Identifiers a service exchange where the client is creating a PAKE session by authenticating the client's PIN and context key.</li> </ul> <p>These service type exchanges SHOULD use the following encryption modes (<code>enc</code> parameter value).</p> <ul> <li><code>pin_registration</code> : <code>device</code> - Specifying encryption to a device-bound key.</li> <li><code>pin_change</code> : <code>user</code> - Specifying that all data is encrypted using a PAKE negotiated session key. The session key MUST be negotiated under the old PIN to ensure that the user has successfully authenticated using the old PIN before any PIN change is allowed.</li> <li><code>authenticate</code> : <code>device</code> - Specifying encryption to a device-bound key.</li> </ul>"},{"location":"R2PS-protocol/#331-pake-service-type-data-structures","title":"3.3.1 PAKE service type data structures","text":"<p>All PAKE service types share common service request and response service data structures. Content requirements and requirements on mandatory or optional use of defined data parameters is specified by the underlying PAKE protocol</p>"},{"location":"R2PS-protocol/#3311-pake-service-request-data-structure","title":"3.3.1.1 PAKE service request data structure","text":"<p>The PAKE request data structure includes a JSON string that holds a JSON object with the following parameters:</p> <ul> <li><code>protocol</code> : (string) - Identifier of the PAKE protocol used</li> <li><code>state</code> : (string) - Identifier of the state of the PAKE protocol</li> <li><code>authorization</code> : (byte array) - Authorization data for new PIN registrations</li> <li><code>req</code> : (byte array) - PAKE request data</li> </ul> <p>This document defines the <code>protocol</code> identifier <code>opaque</code> for the OPAQUE protocol (RFC 9807) in section 3.3.3. Profiles of this specification MAY define other identifiers for other PAKE protocols.</p> <p>The <code>authorization</code> parameter, when sent, contains a value that asserts that the client is authorized to set a PIN for this particular client and context. The process through which this authorization code is agreed between the client and the server is outside the scope of this specification. Examples of such a process could be a one-time code sent to the client through a separate channel or the result of some challenge response algorithm.</p>"},{"location":"R2PS-protocol/#3312-pake-service-response-data-structure","title":"3.3.1.2 PAKE service response data structure","text":"<p>The PAKE response data structure includes a JSON string that holds a JSON object with the following parameters:</p> <ul> <li><code>pake_session_id</code> (string) - The session identifier of a created PAKE session</li> <li><code>resp</code> (byte array) - The PAKE response data for the identified state</li> <li><code>msg</code> (string) - Message</li> </ul>"},{"location":"R2PS-protocol/#332-pin-hardening","title":"3.3.2 PIN Hardening","text":"<p>Implementations of this protocol SHOULD use PIN hardening to create strong cryptographic separation between different security contexts and to increase protection against off-line PIN guessing attacks by the server when using low-entropy user passwords/PINs. The choice of using PIN hardening remains, however, an implementer's choice based on the security requirements on the system that implements the protocol.</p> <p>It should be noted that any attempt to establish a PAKE session using the wrong context key will fail as all PAKE requests are signed by the context key. This will cause any attempt to establish a PAKE shared key using an unauthorized context to fail due to signature validation failure. With PIN-hardening, however, the actual PAKE PIN verification is guaranteed to fail due to PIN mismatch, providing a stronger cryptographic separation.</p> <p>Any PIN hardening algorithm can be selected without effecting interoperability as long as:</p> <ul> <li>The PIN hardening algorithm is deterministic and produces the same hardened PIN for a given PIN and context key pair.</li> <li>The same PIN hardening algorithm is used for authentication used during PIN registration.</li> <li>PIN hardening is influenced by the private context key used in the PAKE process</li> </ul> <p>The following PIN hardening algorithm is recommended:</p> <p>Hardened PIN = HKDF (Diffie-Hellman(context private key, hash2Curve(PIN)))</p> <p>hash2Curve(PIN) is defined in [RFC 9380]. This algorithm guarantees constant time and uniform distribution. However, a simpler hashing method without these properties could be used to simplify client implementations.</p> <p>Note that hash2Curve is used also in the OPRF [RFC 9497] evaluation process of OPAQUE. It is recommended to use RFC 9380 here, as mandated by the OPAQUE [RFC TBD - Under publication] standard. Other simpler methods could be used, but this does require careful security analysis to ensure that the end protocol implementation meets necessary security goals. This is relevant in particular for requirements on constant time execution and requirements on random distribution of hash result bytes.</p>"},{"location":"R2PS-protocol/#333-opaque-as-pake-protocol","title":"3.3.3 OPAQUE as PAKE protocol","text":"<p>OPAQUE [RFC TBD - Under publication] when used as the PAKE protocol is identified by the protocol identifier <code>opaque</code>.</p> <p>OPAQUE uses the following defined state identifiers:</p> <ul> <li><code>evaluate</code> - Identifies the initial server evaluation state where the server evaluates the blinded OPRF data.</li> <li><code>finalize</code> - Identifies the final state where PIN registration or authentication is finalized.</li> </ul> <p>When OPAQUE is used for PIN registration, the <code>evaluate</code> state exchanges the registration request and registration response, while the <code>finalize</code> state is used to exchange the registration record as per section 3.2 of OPAQUE [RFC TBD].</p> <p>When OPAQUE is used for authenticated key exchange (authentication), the <code>evaluate</code> state exchanges \"AKE message 1\" and \"AKE message 2\" and the <code>finalize</code> state exchanges \"AKE message 3\" as per section 3.3 of OPAQUE [RFC TBD].</p>"},{"location":"R2PS-protocol/#3331-opaque-pin-registration-exchange","title":"3.3.3.1 OPAQUE PIN registration exchange","text":"<p>WHen OPAQUE is used for PIN registration, the following structured JSON data is sent in the data parameter of the main protocol:</p> <p>Evaluate request:</p> <ul> <li><code>protocol</code> : \"opaque\"</li> <li><code>state</code> : \"evaluate\"</li> <li><code>req</code> : Registration request bytes</li> </ul> <p>Evaluate response:</p> <ul> <li><code>resp</code> : The registration response bytes</li> </ul> <p>Finalize request:</p> <ul> <li><code>protocol</code> : \"opaque\"</li> <li><code>state</code> : \"finalize\"</li> <li><code>authorization</code> : Authorization data on initial PIN registration requests, null on PIN change</li> <li><code>req</code> : Registration record bytes</li> </ul> <p>Finalize response:</p> <ul> <li><code>msg</code> : The string \"OK\" if the registration record was accepted</li> </ul> <p>The registration process of OPAQUE is stateless in the sense that the server does not store any information from the <code>evaluate</code> exchange. The client just uses this initial exchange to calculate the registration record sent in the <code>finalize</code> state. This is why the authorization parameter MUST be sent under the <code>finalize</code> state on initial PIN registration.</p> <p>The authorization parameter contains authorization data exchanged between the server and the client by means outside of this protocol, such as a PIN reset code via mail or QR code.</p> <p>The authorization code is not sent on PIN change, as the data parameter is sent encrypted under the old PIN session key (see the section below on PIN change).</p> <p>Exchange example:</p> <p>Service request - evaluate:</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"b8b3b44c098eff93abccd94e27c06488465af1584c887946946c25f3dae89615\",\n  \"iat\" : 1753970875,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lKWVIzUkxka2d3YzBsc1JreDZaVWsyTlVKYWVqbHRZbFpYYUZkR09IQkhieTA0Y0ZOR1NtY3hURWxaSWl3aWVTSTZJbll3Y1V0Q1kyeGphVTVCYkUxWWEzZHZYMHczWVRRMFIyVjFRVEJIYnpkb1dteEVWVlJmUnkxUlNHTWlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLktiNkRhQ2dOd2pfSmEwUkkuVzRpYi1tQllqWXdBTldrWmdlSmJ3ZWlIUFg3aEs3cTFBOWVvR3Q3eXJfUWU3ZFhZMzloX21hQ3ZpZVZ2STdyamF4R0FoVDRLdm1QcFJmQnhoX0hKTWUzTkQxcTdoeWZZZkFQblFXbnVFV2lWSUZzUE94MzJKVk9Sa3pObi5kTUlOM1Q2UFNFbUx5Y3JKU2tSbElR\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"Ar2IGiWEJnjb57P2V4hLQIaDZuzmt54bN227obY5NSIL\",\n  \"context\" : \"hsm\",\n  \"type\" : \"pin_registration\"\n}\n</code></pre> <p>Parsed and decrypted data content <pre><code>{\n  \"protocol\" : \"opaque\",\n  \"state\" : \"evaluate\",\n  \"req\" : \"A2VhN509hDBZqjH+1eX8zMxTNjgUGelYGUUjs5raLmAa\"\n}\n</code></pre></p> <p>Service response - evaluate:</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"b8b3b44c098eff93abccd94e27c06488465af1584c887946946c25f3dae89615\",\n  \"iat\" : 1753970875,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lJMlVscEtVVkZpTldKMFVrSjZSMVpyYWpSdGNERjNhakpDTjA5Mk9XdDFZa2RsVVdNeU9IVmhaMUJGSWl3aWVTSTZJbUZKVkRWbWFHVnBUVFJCY21zeGRua3hXblF3YlRSS1NWQllUMGRrY21kMlMyUnBabEptWHpKQ1lrRWlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLjdVbkk1ZmJ6WlFfTmVnMHkuTk9kY2wzUWE3MDAtYjdEeHV0d2UtelVKLTE0Z2lhamJyWEtsYTFaanJrb1d3U0VFaDhjWW40VEhxb0RFNkFyX194MTBIY2VYNEVEREd1emJqNGZSS25qTy02Tms3MmFJZHpVSnl1QkFwNThVRWNrWWhNMjduMkM3dFVLbXhrR0tvb0c5Lnp2WDY1WW11MHRPd2xLS1Fmd3phTlE=\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"resp\" : \"A/O9ULDVsOAmUnEqypBsO2f8qLL6gjkxTMn3itCfdEgUAtq6rBdVXhCVNy4BV6lOTOKkjV/KshjUVheUB/ctmAA3\"\n}\n</code></pre></p> <p>Service request - finalize:</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"5b869f34b41fe762f2c9977aadfe8fdb78073fed1558a38e02bd95fa322b4149\",\n  \"iat\" : 1753970875,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lJeFJ6Y3dTelJWVXpseFFUZFNRWEk0YUhsTlJGOTNNM3B1TW5waVFWSlpOV3hSWTJoTVUxVndVMGxuSWl3aWVTSTZJbXB1VjJWeWNrNHdjM3BPV25ZNFdXSXhMVTQxVUZSNGFHRlZjR1JmYzFOeGVGUTFkbGhJU0ZCeUxXTWlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLklpX21DazZ5UTNLc3FYbzAuMnBDblZObWNBa3hVZTRuM291MnRJVkhxSFc3MnhrYlBLdExFc3NlMkVZZ29fUU9OdjdKNjlySzFJQmVNTDFpYlo3RklMdzNJZ0JycjlQSEZpbE1fY3RUREgydDNYajB0YjM1cUNNV1N2bTRwWTRKQkZaeHR3V2ZGU1hJcHlsVGFuUk1uQ2FEeE9yU0FmVEVEV1JnNnF1TGYwMVRNRXJ6S05MN3dEVjBMMWpYSEVMVGk1ejI5WTZCajJHOWJpNWpKbWc1VVAyUHFkYmI5MmxoVl9OUWhBZ2hPT1B3R21wMEtaaDBySFJfZURGRDd1THhPaFROTXRaTFVFQ0NOMDEzTWRSV2RSWV9jaldjaXhlMUN1TVpNbE91VkdYOWNzVlpHSHd3aWZRVnBlLV8wb2lXWTFsNURTNmNzdTM5bFBlUTNyclVxc1VBQjRMZTRub1ZDLmlRNFYwc1hMM09wbHdvSEJobXNaaGc=\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"Ar2IGiWEJnjb57P2V4hLQIaDZuzmt54bN227obY5NSIL\",\n  \"context\" : \"hsm\",\n  \"type\" : \"pin_registration\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"protocol\" : \"opaque\",\n  \"state\" : \"finalize\",\n  \"authorization\" : \"OTg3NjU0MzIx\",\n  \"req\" : \"A2gjTwAIFoD62qTbFPuIwSS96w7CTfsHlnLZOlsdKuBFKwLBZYFbhLrE2tTbZ9qZfxuRADrEUfMdVOf3l4cCtVyPMMZbKMncJQByKEyquVuT3hjF19fpacbgB11zyvG7IT3BqTZo84ThAAQWPmybdl1ZPuxlaMr6kYknKJgmmQOn\"\n}\n</code></pre></p> <p>Service response - finalize:</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"5b869f34b41fe762f2c9977aadfe8fdb78073fed1558a38e02bd95fa322b4149\",\n  \"iat\" : 1753970875,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lKblFUbFhRMVJzZFRGWldDMVBlR294V25CWFVFZEtXVEJKTjNweFMwbHlXRGg2YldkT1dWTnVRVFJ2SWl3aWVTSTZJbUZSZURKbVRtWnVkbmxqZGpkdlVHdDZjek53YlMxNGNXaE5ObkYwWDIxUFQxSmFOek53Wkc5U2RFMGlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLjRoa19fTHJzMzFQODIwM3QuR095VW5VS2dMOXEtdWlMUi5Tb2JTc2ZGaTNIeFlDM2FyWHItd2Vn\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"msg\" : \"OK\"\n}\n</code></pre></p>"},{"location":"R2PS-protocol/#3332-opaque-authentication-create-session-with-a-session-key","title":"3.3.3.2 OPAQUE authentication (Create session with a session key)","text":"<p>WHen OPAQUE is used for authentication, the following structured JSON data is sent in the data parameter of the main protocol:</p> <p>Evaluate request:</p> <ul> <li><code>protocol</code> : \"opaque\"</li> <li><code>state</code> : \"evaluate\"</li> <li><code>req</code> : AKE message 1 (KE1) bytes</li> </ul> <p>Evaluate response:</p> <ul> <li><code>pake_session_id</code> : Session identifier of the PAKE session being created</li> <li><code>resp</code> : AKE message 2 (KE2) bytes</li> </ul> <p>Finalize request:</p> <ul> <li><code>protocol</code> : \"opaque\"</li> <li><code>state</code> : \"finalize\"</li> <li><code>req</code> : AKE message 3 (KE3) bytes</li> </ul> <p>Finalize response:</p> <ul> <li><code>msg</code> : The string \"OK\" if authentication was successful</li> </ul> <p>The authentication process of OPAQUE has state in the sense that the client and server store data from the <code>evaluate</code> exchange that is used in the <code>finalize</code> exchange. This is why the <code>pake_session_id</code> is returned already in the <code>evaluate</code> state exchange. This <code>pake_session_id</code> MUST then be returned to the server in the <code>finalize</code> exchange as a reference to the associated <code>evaluate</code> exchange.</p> <p>Exchange example:</p> <p>Service request - evaluate:</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"45c38e7db0993b35210f5cb05b73dc33fe9dd855ad32e2c641dd0e28b943961c\",\n  \"iat\" : 1753970875,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lKaVR6VktiSEpPUzNWbFR5MWFhVmMxVWpWdE9GaG9NRXRZZUhoeE56ZFVUbTU0TUZVd2NXeHpZV2xWSWl3aWVTSTZJblJJWm5WSWNIWTJlblZuT0hKbE9XOVVNWEUxVERWUGRXaDBNV3B1Y21kS1UyVnZWMWhYWTNGR2VXTWlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLnhWUjBPWndiM2VMRVRuNkwuTG9QUTdVdmdKQ1pNWlRpSW4wRF9yNHdKSi0yNUY5bWQ5S0JfQUpFX3BDVzJpUEZRSkdNYnZFSVpTMmZ1dHRSS0RzUkhPOGZ4X3Mydnktb05KTUlHZjVScmR0YWlTdHJTeEhWY21BajU4M2dPTGNSMzM1RFRYQXF4Tk01OXNyeG8tUWRsYlFqZ05xMVNPU3dTLXVRR0JPTGx0d1cyYXBZbHpwUmhDc3d5SkpuQktlWEVORDhNLWhydXBVUUwxWjJmS1VOVklFaFFhaEJRSUE5VWl5aWxnVllVVmhDcTVHelRSSTlrNzRDeFBaeWRZTmdVbWcudE1JUDNYVFF5clhQX0tPbEVOMlRxdw==\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"A06RIGh7ANlE20pJ+4SW9yn765QDG/qe9eRsP6ucdNWY\",\n  \"context\" : \"test\",\n  \"type\" : \"authenticate\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"protocol\" : \"opaque\",\n  \"state\" : \"evaluate\",\n  \"req\" : \"Ayw6J1aUYVxAbQVbl5Y5siT8ikF/FRJntNyxqnsGgFvYdlz+y65eL4Q8THF6bYwmebqC3t6Q/EqvSInVtgojyIYDoFTmpNYccKUgfDG9PhHo4KvfRSW799HOXhGZWkL71As=\"\n}\n</code></pre></p> <p>Service response - evaluate:</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"45c38e7db0993b35210f5cb05b73dc33fe9dd855ad32e2c641dd0e28b943961c\",\n  \"iat\" : 1753970875,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lKbFNFSmhUa1JCUVVaSmEyOWhaMk5TVlUweFpsbFFTQzE1VDFkWWJISnJZbEpxZEVSbmVHYzViMEp6SWl3aWVTSTZJakJOZG1OS04yMTFhMGh2YUU1c01WRnNZa0ZYVTNaNGNHWjZRa0l3T1ZKUk5qQXhPV2RpUTNkS2JXOGlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLjIxeFpCV2JWR216UVkyNXYua2lxVXU0UEVqU3BlYVFoazFHTmh3N2w0eEZEUnNsc3JVWmVVTy1uNU41NlB5V3Jvb0NXcGFGbV9XbDEwb3BjQnhrYmxHbDlicE8xb1VodEc0R3ZoM1liR2xQMWVNQUMySXhKdkduekxuT3VGa3pMZ1dJMGVVMDEwWUZDN0J5N19qNDY2VThYVEtvTzNjMHpKWGx5NGJGNnVkRlYwNVZYRmRobzFnS04zeHVBUFVPVEp2MnM4eUxwMFlhaVJmd0Y3SEpfWXptRm85YUF1OGpVWXo0R2ZEbmJ2Tnc4YWtvd1BUWVM4NTVmU0FrVDJRQWFURVhQdFczZjZQMWZqaFNQWTB5NU5TRkhpRFdGSTJaS3A0bzFFVm5GOXI0NDBkUjBIT3Rwbkx5OU9NeldZNUotbHEzRU9uUExLbUtiQkxmc2tId0VydC1HYVVEWW5BQ2dDbno4d3FPUkNTWVVGUTNNbzNMaWJ1Zko3SXhWUXN3cjhDWmNuM0NFUTAxZ1BwLWdYeGIweXBuNFR4NGpCOG1EY1NFenFJQ2dtUGVPN29fNmdmb2Nrd3ZEcjVTaGRzakJhdWVjaktnS2lWc0YzRVo3Vmh0cl9tTmQ2Y1hjVE1XaWtrd0hjQzZuMVZnZzJWSXByczR2ZmZhSF96Wm4tSzV4c3BXY2lDNTIxb0dHMGNYZGt5UnpKYkJkR0dYcnYzdEF0OXNISUV3OHJ4Z2x4dlA4OHkteGFZLTlLa3d5VWtBS3Z3MW9HWkI1LWhudEFnY2RCUjlzdHVzN1gwb2V4NmxuYy4tYmdsci0yWnhLcDFUQnk1Y3FBSDN3\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"pake_session_id\" : \"1332f2c7b64c8eb2c2f2c95bca4d71988badc2cac351408af78ac6a4552a56cd\",\n  \"resp\" : \"A0HE/aHekqoVZotwnR4ZlHH1VRIeKi1EuZ5Nb4uS9DuRBSv2dq6/eYWoMcV3yEwO9sBv5qG+wpuvTQ0+pIJ6xJUeAI2pqHdWFTWS8IfgwSyu2t/bJJTELvbZllKSRyl86dIkTrQwxtilUKob0NkMvBLUrOfBnVGblU0AMJPqYD7LRoQrOmAEecduVxlnypMmEo6UHyinprjOpgUF9auhuopgb0W0gbc0/YtLCAIAK1Cf0C0tuH+o0X5T4PLl+tPzi3wC5k+90ZWRKzFS5ZCuhT7tF9rbOvCRYBxHFIw/HATuJOv4/x05g02evdMY/wQtZaKPUlQYRIlAEN5Cjg/bWYMbqw==\"\n}\n</code></pre></p> <p>Service request - finalize:</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"1207c42b0702b6de3c95dc2248213156932c4c125a8cd215d54a58386d8b8fd3\",\n  \"iat\" : 1753970875,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lKU2NUbFJOMDFpWnkxUk5IVkZURjlUTkVoSFVWRTJZbkF6V2tRNFN6aEZWR2hhZFZGTVRXeDJjRE5aSWl3aWVTSTZJamhhU201SlQyZGFRV1J0ZVdoRmEzZHZlR3d4VWtodmVFbG1OV2RqVVRrd2JIb3hSWE5QZVMwM1RtY2lmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLmR1S2xVYThyRTgySU9LSzcuaXB1azBTUjVIbUVZd25ieF9WTUFUb20xODVlWXJMb2FBZXZ0N0F3SEYtYXpOV0RFSzc4QXZCLUpyTWxRTTdBNUZ6SDFtblFHN2VJVEtyc1FZUzFzMjc5cXY1cktjbGZuN3lHRjZpdG5rd1NaaWhnY1FVMlo3a242MDRSdS53b3NVUUk5d3lPVDh2UmEyNWY1ZE1n\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"A06RIGh7ANlE20pJ+4SW9yn765QDG/qe9eRsP6ucdNWY\",\n  \"context\" : \"test\",\n  \"type\" : \"authenticate\",\n  \"pake_session_id\" : \"1332f2c7b64c8eb2c2f2c95bca4d71988badc2cac351408af78ac6a4552a56cd\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"protocol\" : \"opaque\",\n  \"state\" : \"finalize\",\n  \"req\" : \"rs7OM+/ZCMoWIkisEiWJhzc7rD97BCZYfsCBj5V4J5A=\"\n}\n</code></pre></p> <p>Service response - finalize:</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"1207c42b0702b6de3c95dc2248213156932c4c125a8cd215d54a58386d8b8fd3\",\n  \"iat\" : 1753970875,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lJeFdqaG9aV2c1YWpVd2JqVTBUbVZHVDE5VmExOVFOVzlmU1dsRFozQmtSR1pCTlcwdFIxTjFVM0ZySWl3aWVTSTZJbmczVkZOeVQzVkNjWEZIT0RKQ1JXUnhkVFZXVVhFd1RtWndZVU5mZUhWMGRITjNXVU01T0hsR1VrMGlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLlZBUU15SFFwR3ZJS2Z4YlMuSmlZUzJSRHZkWk91dEFaVy4wNzloYjJqZWN1YUZ3Z2I1N1U5aXNB\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"msg\" : \"OK\"\n}\n</code></pre></p>"},{"location":"R2PS-protocol/#3333-opaque-pin-change","title":"3.3.3.3 OPAQUE PIN change","text":"<p>PIN change is done using the following steps:</p> <ul> <li>A new PAKE session is created under the old PIN</li> <li>A PIN change (new PIN registration) exchange is made encrypted under the session key created under the Old PIN.</li> </ul> <p>Once this is complete, a normal operation would then be to invalidate the session under the old PIN and to create a new session under the new PIN. This is not illustrated in the example below.</p> <p>Example of a complete PIN change exchange:</p> <p>Authenticate with old PIN - evaluate request</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"4d113cb59e52304226a4d6c4c110c2a68680c784d097a1d6284037bd93dadc8d\",\n  \"iat\" : 1754008895,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lKSWRYWldaRGRCUlZka1drbEdlVWRsZG1FMlkyTklTeTFXVWt0clVIVXliSGxrU1V4TmFqQTFlVVJGSWl3aWVTSTZJbVJ2VFhOdUxWWlBiRVZ2Y1dSd04yVnliMkpVZDFWVmMwMDNTSGxpVjFsSE1sZHlNME14ZVZSVlNYTWlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLjBBZFZvMGxLbExSS01sQzcuVjZyU0h1WngtLWN4N2hrQ3g3aFgya2JVZENOWDUyTno0UXF1ZHJNV19nMEtiY0FMOVQyclBHc0tKdExrOU1LUlhVV1p3TjNMN1FaTjhkSGs1a2E2Y0I5Zml0U1NHcFZJdl9aNC0tdHNWUkhqbnI4MjBmVkxmUU1faHNfNDZYRFg3ZUt0UUVVT2IzZkVSYmRYVjJhQTMwcVVJUy1ud01xVzJneWNXUUZEOE1ma3pNb3ZlZThiY3otVlF5QWVQaFF2YW9GRTZMWGVIWERyM0FoY2NJcUo0OGhZVEgtRDdzSmJmYUJfd3I1OE1rV3lRY240bEEucE5PT1Iwd0tGQzk3VUVRclNxYzh3dw==\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"A06RIGh7ANlE20pJ+4SW9yn765QDG/qe9eRsP6ucdNWY\",\n  \"context\" : \"test\",\n  \"type\" : \"authenticate\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"protocol\" : \"opaque\",\n  \"state\" : \"evaluate\",\n  \"req\" : \"A4OKak5KWXH3exxZbYWNu56TSJLLihak3VADkdrm/ZFQojL6Ptcb8v1ha/1+/UuFdr+S84litnM0ci97VsiyN4YCXnUzLQrBMXOzfyDN7omWzF2SVh3Q56Qq3IPLcULwImA=\"\n}\n</code></pre></p> <p>Authenticate with old PIN - evaluate response</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"4d113cb59e52304226a4d6c4c110c2a68680c784d097a1d6284037bd93dadc8d\",\n  \"iat\" : 1754008895,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lKamJucEJjM1V6WWtWcGFtSkZNRk5NTVd4dGNWQmpVRFV5VWpCUGFubFJUelI2VlVOUGEzQlhPR2xSSWl3aWVTSTZJa3R4V21KNWFVSlpjVlJ0ZG0xTWVqZHlhbEJPTVU1TE5teENRVUUzWTI0eWNXZDFjalpDZDFwTGJuTWlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLkpCYmo1NlRpeXYzSGRhOXguUWdhN1ZFMHdsUWRNVkI3Z2VDdkdYWXhvUTVUSm5yUWJLbGZQQVZKZy1uVy0ya3hTeGlDT3N2YjNaaUhwVmF1LWNZcVEtLVJDcmdvUElvUHp0M1hfaUFhNkZSeFVDbkh1TzBfeVN3UFhsalF0MlkzXzNxRWV5S0E2aXVKNi1HVHZpYTgtaHFJUGxWcWxSY0xQTnNsVnlqZ0c5eEZfUGZZZFdZMDBMUzRabFRZeTdLZDJPS0RrSldLeC1tZ2pxUTRtY3MtWUlzcjRObG1oaGIxVzZ4QTFua0U5QTM3dF9hMWZ3VlNoeDVxWmhJSm1yc0ZjSTliYzI0cnFocFpmdnFoc3BTdnJTaG1ldnFOLTNSYkdQX2FnUV9nei03aUpVTzZaWHliSWxKc251bmdFS2RtbXVGYThTQ3VFcDBEaFgtTUxEYVhVZlQtOVpDeWxGR1lMSGMyN0lUS3NMeER3UlhGdDVMM2dITWoyVHdBbjFpYjkyRDBDN3ZjWnMtaXM5Sk43X2RraUlRLTVJZWpRTUNrN0JpX3d5VzViMXNhcUctbEM0TVFad21FalhJd2MwVXdoX25MSl91QmZvRmZWRUVZNFdHcWVxXy0xX0hYanhQNWRKSnZzLThSS19vc3ZVZzVQM0hLSm9hMHc5a245YUo0R2syWkFCVl9BMDJFczcyVUVjMU1xTTFFZTllWHdPRkNsUWFyWDNjd3lpd2pQV2d4NzhpNDlQM2pFcE9JTk9SaUlUN2hzekNKamJJRmJ0LWRBWnFqRkl4Z1J0a0tRWDZNVi5MM0ZUTS1SenFjOUtZaTdDWEVzNEN3\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"pake_session_id\" : \"6fe6e2c0bb0fe89d426783b2d78cd416b379452330dba758172d013d4a4e0508\",\n  \"resp\" : \"A/KBWT8RocPPJEA3uQF+gq+amHLDgiqy8ouBHqDsAxE3CnmLT90psJ7ua/eqsBaUWSRxwlR5Z0FGLQ8uw/CVFwY/kdYMP5WJ/ZCoj9sPerF9bW2zPXztq1Gs/LvghMm8xWLwjneGMFseRel8HmGQjiG15uCDrgIwoKR9CIzIvu3IraofBaWbHjT4nEVS4CadSaOnRlT4akyySHUhe21ZmPfHYpjqoaRwKeFoJcWYc8yQhjzExV1Q9OcBkGqzMMM6PeMD58cU4UHRur4sCRNDJvNAiwP48TrtCxh94U8ILy21a/ZdgveeA7p5QGPup8L8HU/xIFYoFp8N5qzNUpDFcbL86A==\"\n}\n</code></pre></p> <p>Authenticate with old PIN - finalize request</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"a652648d3498e31c0747b0c1536b98c8aadf59f7cb7bd528ad527f05f395511c\",\n  \"iat\" : 1754008895,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lJeFVXVlRVM05KZWtRNGMycElOM0V6UlVwc2JXRkJhbXRFYlZFNWJWVTViVnB5TUUxVVpXcE1SeTFqSWl3aWVTSTZJa1pGV1RoTmNEUmtSa2xwZVZSd2FFaHRPVmxTTTNWR1NGazBXVkpwYTA5SVRrZHRXWE4zUVdRNU4xVWlmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLkFSbFlkNFVFdUxITEtELTIuNk03RDJKM2w3S0hfb3kxdDBpZ3BPbVZpaFo0SlhvRHFBeFVFd0JmZmtobm5jNlFaWl9UTGtSQ0x6ODlKdl85LXR2RGtnVjQ3V3czRERmNXdQYm9Md2lSRGZqd0VzWnFjVjZxaVlJMndSak9tcUhYZUttUjNNb2V3Ui1MVi5FR1doTHNSdTBTUGRFUXRKWm5oNEdB\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"A06RIGh7ANlE20pJ+4SW9yn765QDG/qe9eRsP6ucdNWY\",\n  \"context\" : \"test\",\n  \"type\" : \"authenticate\",\n  \"pake_session_id\" : \"6fe6e2c0bb0fe89d426783b2d78cd416b379452330dba758172d013d4a4e0508\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"protocol\" : \"opaque\",\n  \"state\" : \"finalize\",\n  \"req\" : \"+zoSyAQJMXXzDYP2NA6s9vIHrih4BWhxUDVLl904r/0=\"\n}\n</code></pre></p> <p>Authenticate with old PIN - finalize response</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"a652648d3498e31c0747b0c1536b98c8aadf59f7cb7bd528ad527f05f395511c\",\n  \"iat\" : 1754008895,\n  \"enc\" : \"device\",\n  \"data\" : \"ZXlKbGNHc2lPbnNpYTNSNUlqb2lSVU1pTENKamNuWWlPaUpRTFRJMU5pSXNJbmdpT2lJNVFUUnplVWRxYmxwa2RYWlNWSGxyT1hsdVFrSmpibE5EYkhoeVlVWlZSRTlTTUhKUFdXWkJja3h6SWl3aWVTSTZJbGRLY1hoTlpXdHZSbVJTTkdaSlFuRk5aMUpxVFhKMlZEZzNRVVprVDBsQ2VsaFZVWFJaY25NdFMyc2lmU3dpWTNSNUlqb2lZWEJ3YkdsallYUnBiMjR2YjJOMFpYUXRjM1J5WldGdElpd2laVzVqSWpvaVFUSTFOa2REVFNJc0ltRnNaeUk2SWtWRFJFZ3RSVk1pZlEuLlVWSm56TnlJZXgwQ0J3dUsuYUh3Z0pnRnQ4QnNpTGQ5My5sVUtkLU1iTVlLNmN4elk1eVJNWHN3\"\n}\n</code></pre> <p>Parsed data content <pre><code>{\n  \"msg\" : \"OK\"\n}\n</code></pre></p> <p>Change PIN - evaluate request</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"23006c6ed0403beec7ef4b85f884f26553087f67a4a96d543a63eca1e75b5d8b\",\n  \"iat\" : 1754008895,\n  \"enc\" : \"user\",\n  \"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5nQk5Bb0dWM2FiZzFGNDFrLjlLcl9XWm5ydS1aemREUWtGdERTUk5BVmlUcmpTbDB6SWhINnlEQ01WbHFOblJ1UVV2Sk5kdDNOb0xfWVNvU19LUjEwQzVMOW9ZOHBvdFBfUlF1NGtfZ2J1VlRIYzdUR2EyTVRwYk5LdDh0MUJ4eS05eHJxRk5KUktoeUsuSlA0dXcxbVZBUlVTTWhHMVd4N2tGQQ==\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"A06RIGh7ANlE20pJ+4SW9yn765QDG/qe9eRsP6ucdNWY\",\n  \"context\" : \"test\",\n  \"type\" : \"pin_change\",\n  \"pake_session_id\" : \"6fe6e2c0bb0fe89d426783b2d78cd416b379452330dba758172d013d4a4e0508\"\n}\n</code></pre> <p>Decrypted JWE data payload <pre><code>{\n  \"protocol\" : \"opaque\",\n  \"state\" : \"evaluate\",\n  \"req\" : \"Al6xR/ilUyThC6Ymk+l40xgUJXh9i0FyCx0u/obhykyp\"\n}\n</code></pre></p> <p>Change PIN - evaluate response</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"23006c6ed0403beec7ef4b85f884f26553087f67a4a96d543a63eca1e75b5d8b\",\n  \"iat\" : 1754008895,\n  \"enc\" : \"user\",\n  \"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5nM3J5VmtYX2JydXc4NnRTLk95RjZObFJPQ0FVOE5lWkp4SXRCLWFNTURMN0hoeUxGek5QNVBwcEZQQ2hXWFo4anQ2RmF0SVVEVVhhTlpkR1lCSHRvYU1tbzMybzBOejdwbVVKNy1XM1Nld2V2SUthVEZUNGIydnNiQnNJVkFuaGdWNmN0dE1GMUxpXzg5UVZRMTZXQy5fenFUb2pfMjV5dVdFNm01VXJEenhn\"\n}\n</code></pre> <p>Decrypted JWE data payload <pre><code>{\n  \"resp\" : \"As8r8bLemY0xNb48L7gPAoSwSo0qLSc5q6eMXZhJ25C9Atq6rBdVXhCVNy4BV6lOTOKkjV/KshjUVheUB/ctmAA3\"\n}\n</code></pre></p> <p>Change PIN - finalize request</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"e1502315b756a6c5b8ec791d6fa03a2828a77964d0ed479375f15a4d03ec8365\",\n  \"iat\" : 1754008895,\n  \"enc\" : \"user\",\n  \"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5BZVUtTVE1YUlYa1JiSzZoLmZBNjFJT2g1aWpyR0V4dHh0endZTk1JYlVwd0NJNWJFMDFCMmVNV0NYdzBuM3kwbkZDM2I1QTRvWGZKZnJxek8zVFBoWGJra2h5RWUwT0UyZjQtNnBUYnIwbFNXM1pFWHZua0pJZGxMdVlRSjltUmxIQXpvOWpEVzljYzh1TzlCZnNyY0s4Q3hMR05hSFRkeEVxR0dFODZack9CU29ZRGhlb1RhLVdWVnhqY2JROFRvWG5XREU2cGZYYzVZSTVXczNBM0NMZzVEaXowTzBjTm14YzM2MTZzRmRIZWh1czVyYjBpTzQ4VXZ0VlBlT096c043ejYzYktrNFJSSkFMbnpENnlyMG56ZHRtdnByZkllWVc2cFlkaHdNU1dRUDdremlBcEJaS28uTHpSX083bF95dERFb1h2WVVtdndMQQ==\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"A06RIGh7ANlE20pJ+4SW9yn765QDG/qe9eRsP6ucdNWY\",\n  \"context\" : \"test\",\n  \"type\" : \"pin_change\",\n  \"pake_session_id\" : \"6fe6e2c0bb0fe89d426783b2d78cd416b379452330dba758172d013d4a4e0508\"\n}\n</code></pre> <p>Decrypted JWE data payload <pre><code>{\n  \"protocol\" : \"opaque\",\n  \"state\" : \"finalize\",\n  \"req\" : \"A+8GixDWn9UOsMwe4HkVgdcxddqaS92zfSf5+HthiJpfPRtEeUAI9yl6ZysfIrUtswVza33C3tv9mlPpYYdX86+3kaStNPZ5YkYIlISyfRMivt1ZegRzTyDZIn2q/E08PwnnAWG42a6C1ZdewvUqiNeTPVRZ31sxTGTx4cf8Cjh9\"\n}\n</code></pre></p> <p>Change PIN - finalize response</p> <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"e1502315b756a6c5b8ec791d6fa03a2828a77964d0ed479375f15a4d03ec8365\",\n  \"iat\" : 1754008895,\n  \"enc\" : \"user\",\n  \"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi53bWpQb0pPUHNPcHBld21uLlJaNFdOTlh6eklJdS1fQzEuNFlieTBvd3FBSzRlNnozRkVCejVnZw==\"\n}\n</code></pre> <p>Decrypted JWE data payload <pre><code>{\n  \"msg\" : \"OK\"\n}\n</code></pre></p>"},{"location":"R2PS-protocol/#4-service-type-definitions","title":"4 Service type definitions","text":"<p>This base profile only defines service types for PIN registration, PIN change, and PAKE authentication, providing the basic platform for creating encrypted session exchange.</p> <p>Profiles of this document can define any number of service types and the data structures that are communicated under within each service type exchange.</p> <p>Each service type MUST define the following:</p> <ul> <li>The identifier of the service type</li> <li>The data structures that are exchanged (requests and responses)</li> <li>The encryption mode used to encrypt service data.</li> </ul> <p>A server that receives service data encrypted under the wrong mode MUST reject the service request with the error UNAUTHORIZED.</p>"},{"location":"R2PS-protocol/#appendix-a-guidance-on-security-context-usage","title":"Appendix A: Guidance on security context usage","text":"<p>Informational</p>"},{"location":"R2PS-protocol/#a1-separation-of-security-context","title":"A.1 Separation of security context","text":"<p>The security context as defined in this specification is a versatile tool that presents options for the deployment infrastructure. How this tool is used is entirely up to the implementer. This section offers some guidance on the rationale for this design and for what purpose it was intended.</p> <p>A typical use case for security context separation is if a particular process is:</p> <p>1) Subject to separate security evaluation and/or certification 2) Requires separate PIN verification (such as a signing process)</p> <p>Use-case: Remote HSM</p> <p>When a wallet application needs certification against requirements to use an HSM protected key, then it would be suitable to execute all HSM operations under a separate security context. This enforces that only the client application resource that has access to the \"HSM\" client context key can create a secure session under that context and successfully request operations on the HSM protected keys.</p> <p>Use-case: Signing process with separate PIN validation</p> <p>This is applicable when the usage of a dedicated signing key requires PIN validation for each instance of usage. This can be achieved by a unique security context in combination with a service handler policy that imposes restrictions on services handled in a session under that context. Such a context-dependent service handler policy could be:</p> <p>1) This context restricts usage of a particular key 2) A service request must be received at a maximum time after session creation 3) A context session is deleted after one service operation (with the designated key).</p>"},{"location":"R2PS-protocol/#a2-cryptographic-separation-between-security-contexts","title":"A.2 Cryptographic separation between security contexts","text":"<p>A security context, when implemented as intended, offers cryptographic separation between services that are offered under different contexts. It remains an implementer's choice whether each context uses separate context keys or separate user PINs or both. The design is intended to allow usage of the same PIN, for the best user experience, while using separate context keys as the means to achieve cryptographic separation of session keys.</p> <p>Whether cryptographic separation is achieved is ultimately decided by the choice of PIN hardening and the choice of PAKE protocol. The design goal above is met when OPAQUE is used and further reinforced by PIN hardening.</p>"},{"location":"R2PS-protocol/#a3-supporting-multiple-devices-for-a-common-client-id","title":"A.3 Supporting multiple devices for a common client ID","text":"<p>The protocol supports when a client is made available on multiple devices under a common client ID. This could be the case if the same wallet instance is made available to a user on multiple devices but still shares the same data, attestations, and history.</p> <p>This is enabled by allowing a common context to use more than one context key, where each device can generate and register its own unique context key on each device, thus avoiding distribution of private keys between devices.</p> <p>This feature is enabled by the <code>kid</code> parameter in service requests, informing the server of which key that will be used under this context to negotiate a PAKE session.</p> <p>However, sharing the same context key may also be desired, in particular when OPAQUE is used as the PAKE protocol. OPAQUE also outputs a static client storage key. The client can use this key across multiple sessions to encrypt data to be stored on the server in a way that ensures that the server can never decrypt or access this data. However, in this case, we do want multiple devices to extract the same storage key, which requires a context key that is shared among the devices.</p> <p>This is another reason why it is desired to have separate security contexts. While secure services, e.g. HSM key operations, use separate per-device context keys; user storage can be handled by another separate security context using a device-shared context key.</p>"},{"location":"R2PS-service-types/","title":"Common R2PS service types","text":"<p>This document defines common service types exchanged under the R2PS protocol.</p>"},{"location":"R2PS-service-types/#1-hsm-ec-key-generation-request","title":"1 HSM EC key generation request","text":""},{"location":"R2PS-service-types/#11-type-identifier","title":"1.1 Type identifier","text":"<p>The EC HSM key generation service type is identified by the following type identifier:</p> <p>hsm_ec_keygen</p>"},{"location":"R2PS-service-types/#12-service-type-data","title":"1.2. Service type data","text":"<p>This service type generates an EC key for a requested EC curve in the remote HSM, if the request is accepted. If the request is denied, an error response is returned.</p> <p>The service request data includes an encrypted JWE where the payload holds a JSON object with the following parameters: </p> <ul> <li><code>curve</code> : (string) - A registered name of the requested EC curve</li> </ul> <p>The service response </p> <p>data includes an encrypted JWE where the payload holds a JSON object with the following parameters:</p> <ul> <li><code>created_key</code> : (string) - A registered name of the requested EC curve for which a key is created</li> </ul>"},{"location":"R2PS-service-types/#13-example","title":"1.3 Example","text":"<p>Create EC key - service request</p> <pre><code>{\n\"ver\" : \"1.0\",\n\"nonce\" : \"ce1236513eff5bbbc67a24681b236f68dbd414b330ab5320cab9e4c24225dcc3\",\n\"iat\" : 1750750250,\n\"enc\" : \"user\",\n\"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5ScjIza0JyZkpUSVFnWjcxLnVBazlMdmwybHBpZVp0eENoaXBiTzhrLmpsQjN6bE5NcXNzdDhiYjBxMXdLamc=\",\n\"client_id\" : \"https://example.com/wallet/1\",\n\"kid\" : \"Ar2IGiWEJnjb57P2V4hLQIaDZuzmt54bN227obY5NSIL\",\n\"context\" : \"hsm\",\n\"type\" : \"hsm_ec_keygen\",\n\"pake_session_id\" : \"edd1e0eb4c20debf6b3cc3ee84d53d5d419f37206c3c60131d0386f9763e41b0\"\n}\n</code></pre> <p>Decrypted JWE payload</p> <pre><code>{\n\"curve\" : \"P-256\"\n}\n</code></pre> <p>Create EC key - service response <pre><code>{\n\"ver\" : \"1.0\",\n\"nonce\" : \"ce1236513eff5bbbc67a24681b236f68dbd414b330ab5320cab9e4c24225dcc3\",\n\"iat\" : 1750750250,\n\"enc\" : \"user\",\n\"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5CYlFwYmlCSTNVVl9Tb1JQLkN3TEdXN0lzU1Qxd0Mzb255QncyYUd6NWpqM2NNV0EuZDQ0V2dXRWZNeWtGOFZCVzl5Vm1fdw==\"\n}\n</code></pre></p> <p>Decrypted JWE payload <pre><code>{\n\"created_key\" : \"P-256\"\n}\n</code></pre></p>"},{"location":"R2PS-service-types/#2-list-hsm-keys","title":"2 List HSM keys","text":""},{"location":"R2PS-service-types/#21-type-identifier","title":"2.1 Type identifier","text":"<p>The list HSM keys service type is identified by the following type identifier:</p> <p>hsm_list_keys</p>"},{"location":"R2PS-service-types/#22-service-type-data","title":"2.2 Service type data","text":"<p>This service type requests a list of EC keys for specified EC curves that are available in the remote HSM.</p> <p>The service request data includes an encrypted JWE where the payload holds a JSON object with the following parameters:</p> <ul> <li><code>curve</code> : (string array) - An array of registered EC curve names for which key information is requested. Absent or empty list indicates that all keys should be listed.</li> </ul> <p>The service response data includes an encrypted JWE where the payload holds a JSON object with the following parameters:</p> <ul> <li><code>key_info</code> : (object array) - An array of key_info data for each available key.</li> </ul> <p>each <code>key_info</code> object includes the following parameters:</p> <ul> <li><code>kid</code> : (string) - The key identifier used to request operations with this key</li> <li><code>curve_name</code> : (string) - The name of the EC curve specified when requesting this key</li> <li><code>creation_time</code> : (integer) - Seconds since epoch when this key was created</li> <li><code>public_key</code> : (byte array) - The compressed point byte array of the public key</li> </ul>"},{"location":"R2PS-service-types/#23-example","title":"2.3 Example","text":"<p>List HSM keys - service request</p> <pre><code>{\n\"ver\" : \"1.0\",\n\"nonce\" : \"8e85a3cc7d2fe445a32d1319e7641c719267a2c4669da2a71ac03b86021d943c\",\n\"iat\" : 1750751069,\n\"enc\" : \"user\",\n\"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5wbzNyZHd4SjVSMGQ5RUpXLldPaXBnT0tVNUlZU0VVeXYua3lhZmlUajhSWmJya2ZiRVNpb0hxUQ==\",\n\"client_id\" : \"https://example.com/wallet/1\",\n\"kid\" : \"Ar2IGiWEJnjb57P2V4hLQIaDZuzmt54bN227obY5NSIL\",\n\"context\" : \"hsm\",\n\"type\" : \"hsm_list_keys\",\n\"pake_session_id\" : \"e124475e1f39b9823dc6538fffd69193c75e784c7a90d253bca5404ad60ee9ca\"\n}\n</code></pre> <p>Decrypted JWE payload</p> <pre><code>{\n\"curve\" : [ ]\n}\n</code></pre> <p>List HSM keys - service response</p> <pre><code>{\n\"ver\" : \"1.0\",\n\"nonce\" : \"8e85a3cc7d2fe445a32d1319e7641c719267a2c4669da2a71ac03b86021d943c\",\n\"iat\" : 1750751069,\n\"enc\" : \"user\",\n\"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5fdFRLTVU2a2tVa0UtSnhqLlp4WWFCQ0JjZjIyRDg4WVRDdk9SeU14OHBFWGxVaUpWYWpNU1NIb21qU0NEcG1yOXREYmNzVHNnTktVSGRfb2tTM3dEa1pwcThwWHFxT2xNRUs5WVlHRmlCV2I4Q1QzZlRNY0pJMFBtUzBPejhhNy1IcnJEMVM1WXhmSVVJYVFhd0NqYUhxR0t6U0w4Mk9WTldqcUJOR2M3by1kUEdFSXFERDNlWTB4MTN5OU5UaXl4S1lldnN0eVJveS0zQmtUTUQ1U0xlQlFFSmduVWpoWEU4clNkTnpwZ0RTV29QZ202cndBaGdHWFBBdmZZc216OGRMMndjNWdCSmxJMTBaSDJhNkZDeTQzaXBCX0gwRzg0dVRhZUhDbzJMcnQ3alp3NDdGZGVhUHZRY3ZzdEg2MDRaeG5FbzcwZ1hNd2V3ME12eGJ4bW5teV9BS2Q5UTFlLUVqcURXRmJOMWFkTkdzVnp6OTdZZ0tpM05TTVdwWGtfeTZOVkdTV2VuWWZ4by1QQWlObExrdVRYSXllQml6d2ZyMFY2c21ucC1UOVVEbzJjWjE0MHJhTnJoY2dnSnlVNEp2c1lpWjFlZTVacG14Y3dka3hlTlNRMlhCWXNxQndnTU0yWFkwRFRucURZc1plVnlyb0tSRGRLSnh4TFBqVFFEWkxBQmtxNDJuSVR4R3BxWjlub09idE51TzRtd0pWcVR4Mm5YRGhjUmhGNlVhZVNFZmdMTUR4dndaWDM5bUlLMEw2ZHVCUlhfQk82Nks4RTV0cG5LUzN0ZUJuUWFVWEdrSlJPczdKMGVuTUlTNHFzNE1XazlLbmxjM19jTDdmY0M4Y2ZXMENwVExyX2haVlRhRWN2LUN3NENjRm94Sm9MUlE0N1A0b3RHRFgtbWhDb3BMbzQ4LWJiZExJME9UckJIanFzVE51eERFNDFJR3IwVlpjcmlac3M1NnVqQTFHRjYzc3VGa1JGbjIxeE1OVFZJeWUxU1kxOTI1RElrNC1ISzNJY0NYdzZGOV9NbWtYNW1VTmh6QWkzeUhkTWVlS04yQnN3XzdSdG9UVVRWT01zZ0tzS1h5d3ZxSzFhcEhvWTZJTXVXNlgxUW5Ob24ycTZRaGV2WWcybmRUUHBUSlNtTmhUdDctU1RrOFpOMHRXNFRrRjZNNk5wMl9wakNEbjVhQkdSNnk2dlk3V0lyeWRIMUFrRUtzaDVKQl80dzdkQy1CZW5EenBreFotdGdOR0RBZlFVVVhoX3BaRnZmN3M1aTVTTXdIc1NVVXhYaThSZTNSRUdETDBNeWM5WmtYLUprSjNZcVFDeEZ3Ylk2X2VtZDRnQnA1WXprNlZ5VE5VU1c5Vk9nMFhXVlA3ZmNmd1dSV25FSmtoR21ZOGZUVVMzbHgwTmc3bUhhdGJmeXdSVHY0R09mTU1fMzFTVHRaazRTanNfTWtYSkNYRlFaYnZSekM4cllkd3A0VkVVWmJudnpTQ3pva05oSGpHSktCZ1RKam5GbG9ZOVV3OG5LUFVRcFRCXzMtY2p5Y3BQMVNhMVl1RWlNU1hIVTdlOG1Rd1ZnZVVreGJCdEgteDRjekpQOVV1cmlyUXo5MHRPM1lqMEFNbFVhQlBpb2NvVDJid0Ewc2xvT0phbTkzRFBkUzJzZkNxSnZVZTZGa1RuWWlrdFFuY0oyRzhXa1NnTEN2QWJueThlNXpqNy1DS1gyLUdwbENTQmRYVVhkb0pDV0lyY0Z3UkZzc3k4dHEzNWZpb3UtaWxSb2JoeTdGRnlyTkotbjdpbUczdXJrc2xDQlg3ajFaRkdzTUM3aEhXZmJHbFg1bzdRSnF5ejlaeHBNR01zVEEudHhHLWMwU005UUw2SktvaEpsTDMzZw==\"\n}\n</code></pre> <p>Decrypted JWE payload</p> <pre><code>{\n\"key_info\" : [ {\n\"kid\" : \"0308345940bc96d1ea6456ff753596281ff8cec4dfb0a1a82a0a3508b0ac5e17d8072b6bfcc17aa5e6d97d863f2017aa09\",\n\"curve_name\" : \"P-384\",\n\"creation_time\" : 1750751069,\n\"public_key\" : \"MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAECDRZQLyW0epkVv91NZYoH/jOxN+woagqCjUIsKxeF9gHK2v8wXql5tl9hj8gF6oJ3MZ45jdnRNGIG8O+LtWMraR0irerNaHb165jC9+reCXRkVZLr0q7nvgbq18zxuoR\"\n}, {\n\"kid\" : \"03fbe636059033a07ee3099caf84a87474d94afa2c7d431f3391ebd8cf21a24216\",\n\"curve_name\" : \"P-256\",\n\"creation_time\" : 1750751069,\n\"public_key\" : \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE++Y2BZAzoH7jCZyvhKh0dNlK+ix9Qx8zkevYzyGiQhYdmIZjwS5S9fMegmKL685ctyQMNS8Jh1QayMYzwpL4AQ==\"\n}, {\n\"kid\" : \"0301e5a88aca8d54fb87a52cdd5d6f4e8a16f147a10c133b7c4adc4cf3c867f68410d5de1582bc8d74d7f91853758931bd2c8badcd2ff9ab7b49832a4a058451c0a8d2\",\n\"curve_name\" : \"P-521\",\n\"creation_time\" : 1750751069,\n\"public_key\" : \"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQB5aiKyo1U+4elLN1db06KFvFHoQwTO3xK3EzzyGf2hBDV3hWCvI101/kYU3WJMb0si63NL/mre0mDKkoFhFHAqNIBQkoUyt32fqcaSSyf00VQvJHOKF8s7V8SF4HAJpTmFF53uGjoul02v6wy3LPlmKGYpfH/FJcK9/B3oqxDvI5ciis=\"\n} ]\n}\n</code></pre>"},{"location":"R2PS-service-types/#3-ecdsa-sign","title":"3 ECDSA Sign","text":""},{"location":"R2PS-service-types/#31-type-identifier","title":"3.1 Type identifier","text":"<p>The ECDSA sign service type is identified by the following type identifier:</p> <p>hsm_ecdsa</p>"},{"location":"R2PS-service-types/#32-service-type-data","title":"3.2 Service type data","text":"<p>This service type requests an ECDSA signature on a key that is available in the remote HSM.</p> <p>The service request data includes an encrypted JWE where the payload holds a JSON object with the following parameters:</p> <ul> <li><code>kid</code> : (string) - The key identifier of the HSM key.</li> <li><code>tbs_hash</code> : The hashed data to be signed</li> </ul> <p>The service response data includes an encrypted JWE where the payload is the bytes of the generated signature value</p>"},{"location":"R2PS-service-types/#33-example","title":"3.3 Example","text":"<p>Service request - ECDSA sign <pre><code>{\n\"ver\" : \"1.0\",\n\"nonce\" : \"8d704945b58f8ec29de9f7ff01ae8c13598bdb7e77118f206b0076628a2416f0\",\n\"iat\" : 1750751794,\n\"enc\" : \"user\",\n\"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5YLVpGeXpjS3ZSdWsyc3JDLjRrbVJFLTFNZEhqZ0VOaWNDSkZjd1UwY1gxOHdUbTV1aDBZRVA3d2p0WGJJejBsSDZRdkdCU0Vqd1NCNk1ZYVdRNXVGRzNrR2FGMkxob0MwMlY0aXZIbTBhc2lLZlBIaDN1Qy1kSXNnenhVdWJGQjV1Wk9rTGEwSy1rU0hNWU1Oc0lNdExyMUpHTzlNclpYeWhFT1BKZ1R5TS1FdEtEMlJPeHVnVjl0WC1kU1ZTVmM5akh3Lmt5Mk41bk9IcktkekE2aGExVGdkQkE=\",\n\"client_id\" : \"https://example.com/wallet/1\",\n\"kid\" : \"Ar2IGiWEJnjb57P2V4hLQIaDZuzmt54bN227obY5NSIL\",\n\"context\" : \"hsm\",\n\"type\" : \"hsm_ecdsa\",\n\"pake_session_id\" : \"2fd8e97a48d5b26641cfb236bb174e9751507429a252a757313438991ef989f0\"\n}\n</code></pre></p> <p>Decrypted JWE payload</p> <pre><code>{\n\"kid\" : \"02205fb03627f3d6f2100c5c2f156cd8c8da828c168ba7bac39188ac40d648a5dc\",\n\"tbs_hash\" : \"YUHJYghlxa4CTkBEKvtPmiA+jCMUURknHs19sd7bNjs=\"\n}\n</code></pre> <p>Service response - ECDSA sign <pre><code>{\n\"ver\" : \"1.0\",\n\"nonce\" : \"8d704945b58f8ec29de9f7ff01ae8c13598bdb7e77118f206b0076628a2416f0\",\n\"iat\" : 1750751794,\n\"enc\" : \"user\",\n\"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5wUWNFVGh4b1ExbDdvUFdoLmxYSlBQcWNDNF9uYVpNb3ozYXdTeGpkbWxJeWpLczBuUFNTN0FMWkQ4R29DaGVDVWFiUFpLVkx2bFhxemFiS0dyM29Jd1hEYmlqeTBLQ0UwN0tiNEEwdTNmcHlPLXcubU9TV2VUTlVzZVFKLVdmQVBJSlJMQQ==\"\n}\n</code></pre></p> <p>Decrypted JWE payload</p> <pre><code>30440220260a6228484119be74f7f8f46f964af0433b1f1218e667a92e82e45e48ef488d02207cfe73d85a7b81d7853aa680ba4a0ee17120f7fd87b7542b34f79863052abcbf\n</code></pre>"},{"location":"R2PS-service-types/#4-ec-diffie-hellman","title":"4 EC Diffie - Hellman","text":""},{"location":"R2PS-service-types/#41-type-identifier","title":"4.1 Type identifier","text":"<p>The Diffie-Hellman service type is identified by the following type identifier:</p> <p>hsm_ecdh</p>"},{"location":"R2PS-service-types/#42-service-type-data","title":"4.2 Service type data","text":"<p>This service type requests an Diffie-Hellman shared secret using a private key that is available in the remote HSM.</p> <p>The service request data includes an encrypted JWE where the payload holds a JSON object with the following parameters:</p> <ul> <li><code>kid</code> : (string) - The key identifier of the HSM key.</li> <li><code>public_key</code> : The hashed data to be signed</li> </ul> <p>The service response data includes an encrypted JWE where the payload is the bytes of the generated shared secret</p>"},{"location":"R2PS-service-types/#43-example","title":"4.3 Example","text":"<p>Service request - Diffie-Hellman <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"97e5133a6b4f77f93a6d1d29295691d87c2279873d798051c606b3e32eb06028\",\n  \"iat\" : 1750752597,\n  \"enc\" : \"user\",\n  \"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5QVkdkVDVZUzJQR0ZrMmdDLnktRHJMTS1LRDd0R095Qjl4ZEVOUm9DaWVmVm1FcFdrblBZN0F1YzBkU0dmZ3NITmVGcmtCSzNhVDdEZ3VLLUItTWljZzRoZ2JXSU43UTNDeU92cGxkY0RqSm1ZWmE0cDBsbUQ3bExMSzhSX2ZXQ2xOTVZnU3V6TnpIb2FhVUZCb05YV1o2TkpFV2hrM1JXZmZKYm1RbmY4V3FSdHpEb0ZVQTFrS205NU9seTJ4TFo2dVZuX3JrbFk0YmxNTmNqOThSd2tRYjJWYUpFeDJpZDlrTHExencxeFl6Tk9NdWNoX3B4TWpDRm9BbE41WGc3VzYxLXFxbV9RTFgtMkk0MGhmTnBzdjFRaWhJbTF4TjBmallTVk1lZWQ5Qnl4T09pdS5RT2ZuYm1PZE5IT2Y4ZVdNYm4yXy1n\",\n  \"client_id\" : \"https://example.com/wallet/1\",\n  \"kid\" : \"Ar2IGiWEJnjb57P2V4hLQIaDZuzmt54bN227obY5NSIL\",\n  \"context\" : \"hsm\",\n  \"type\" : \"hsm_ecdh\",\n  \"pake_session_id\" : \"5855db90562035cc3999c0dd1b5a5141b16f6180b8e573ce2699536dcbeb75f7\"\n}\n</code></pre></p> <p>Decrypted JWE payload</p> <pre><code>{\n  \"kid\" : \"0294ddc3fd5554688bf619987b63bbb09b13e0d04b8a9da493309eef3f41767228\",\n  \"public_key\" : \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAETpEgaHsA2UTbSkn7hJb3KfvrlAMb+p715Gw/q5x01ZgQZWL7xURVYB9Fw+B7TK+GYMShDJYjLlKva5f+KkTx3w==\"\n}\n</code></pre> <p>Service response - Diffie-Hellman <pre><code>{\n  \"ver\" : \"1.0\",\n  \"nonce\" : \"97e5133a6b4f77f93a6d1d29295691d87c2279873d798051c606b3e32eb06028\",\n  \"iat\" : 1750752597,\n  \"enc\" : \"user\",\n  \"data\" : \"ZXlKbGJtTWlPaUpCTWpVMlIwTk5JaXdpWVd4bklqb2laR2x5SW4wLi5qOEZqbTRwaVdXRmVuTnM0LnFzRFptMS0tZVluOGlnN0Zfd19EUlo1WVlEaXpZakVEdHhiV3BSTHVSaGMuMUx5ODgtaEpIT0JiXzg4NFE1RWZiQQ==\"\n}\n</code></pre></p> <p>Decrypted JWE payload</p> <pre><code>ad91d860a109cce0e7d334813f434be8d44a21f8b3677cfe00c25fb572950687\n</code></pre>"},{"location":"loa-high-access-mechanism/","title":"Assessment and recommendation for a LoA High access mechanism","text":"<p>Security risk 1: A memory dump during the right time reveals the OPAQUE password and allows it to be used from another device without the server knowing.</p> <p>Security risk 2: The server has no way of knowing that the user has input two authentication factors. The PIN-hardening is indistinguishable from an HKDF output using only PIN and software salt.</p> <p>Solution to security risks: use a key attestation to sign all service requests to the server to ensure possession factor, and to mitigate risk of memory dump.</p>"},{"location":"loa-high-access-mechanism/#0-executive-summary","title":"0. Executive summary","text":"<p>This evaluation assesses candidate LoA High access mechanisms for EUDIW, building on the \"Statligt e-leg\" specification and addressing changes introduced by the shift from smart cards to personal smartphones (BYOD).</p> <p>Candidate suitability is decided by two key factors: </p> <ol> <li>The security guarantees provided under specific threats. </li> <li>Functional coverage. Candidates should ideally support most of the capabilities required by the EUDIW use cases.</li> </ol> <p>Ultimately, candidate suitability reflects deeper discussions about core security properties, the role of formal security evaluation, and the required functionality. </p> <p>Pragmatism also matters. Solutions that facilitate certification offer a clear advantage. As certification schemes are still evolving, the preferred option presented here remains contingent on future certification allowances.</p> <p>Our assessment considered a wide range of candidates. Signature-based systems alone are insufficient, and while challenge-response protocols (e.g., SCRAM) appear adequate under certain conditions, they have two fundamental limitations:</p> <ol> <li>The authentication guarantees of protocols like SCRAM are not cryptographically intrinsic (i.e., derived solely from cryptographic protocol design). Instead, guarantees depend on external components and fragile operational assumptions (correct TLS configuration, uncompromised verifiers, secure devices etc.).</li> <li>They often lack forward secrecy, do not enable subsequent session key derivation, and are not trivially composable with other cryptographic workflows.</li> </ol> <p>The above points can be, and have been, contested as the suitability of solution candidates hinges on whether the evaluation prioritizes composable, intrinsic cryptographic guarantees, or is willing to accept security assumptions that are external and conditional.</p> <p>The expert group chose not to recommend any \"basic\" challenge-response protocol. These do not offer formal security guarantees under composability (i.e., resilience when embedded within complex systems), and have insufficient functionality (specifically, the ability to derive additional session key from the exchange alone). </p> <p>Instead, the group evaluated two alternatives: threshold signatures and password-authenticated key exchange (PAKE). Of the two, PAKE offers a more favorable balance of security, implementation maturity, and functional coverage.</p> <p>The recommended solution is OPAQUE, a secure augmented PAKE protocol that has formal proofs of composable, adversarially robust security, thus requiring an HSM only to protect the server's secret key (as opposed to parts of the protocol itself). </p> <p>Note that this recommendation will need to be re-evaluated as certification scheme development progresses.</p>"},{"location":"loa-high-access-mechanism/#1-preliminaries","title":"1. Preliminaries","text":""},{"location":"loa-high-access-mechanism/#11-task-requirements","title":"1.1. Task requirements","text":"<p>Task: Identify and recommend a server-side access mechanism for EUDIW that meets LoA High. Existing solutions from the government e-ID project may be reused.</p> <p>Scope: This evaluation aims to:</p> <ul> <li>Assess changes in requirements resulting from the shift to a wallet-based model.</li> <li>Evaluate access mechanisms likely to meet LoA High.</li> <li>Recommend a compliant mechanism.</li> </ul> <p>This is a theoretical evaluation; no implementation is required.</p> <p>Deliverable: A justified recommendation supported by assurance-level analysis.</p>"},{"location":"loa-high-access-mechanism/#2-results","title":"2. Results","text":""},{"location":"loa-high-access-mechanism/#21-requirements-evaluation","title":"2.1. Requirements evaluation","text":"<p>The technical specification for \"Statligt e-leg\" defines User Authentication, using a PIV-compliant smart card, client middleware (a smartphone app), and a server equipped with an HSM.</p> <p>Increased reliance on smartphones introduces several key changes:</p> <ul> <li>Key Protection becomes more complex due to the heterogeneity of bring your own user devices (BYOD). Smartphones are impractical to certify under EUDIW requirements. Mitigation involves using the smartphone within a national eID scheme for server authentication</li> <li>PIN Verification  is unaffected, as the previous model already used smartphones for knowledge-factor verification.</li> <li>Device Identity Binding is more challenging in multi-device contexts, as there is no longer a single smartcard-based root of trust. Mitigation requires mechanisms to bind devices to a single HSM-secured user account.</li> <li>Recovery and Revocation are more complex. Traditional card-based revocation via a CA is no longer viable, requiring self-service workflows. Re-enrollment remains the primary recovery path, with potential enhancements via threshold-based multi-party schemes and granular recovery parameters.</li> <li>Feature-Rich Wallets enabled by smartphones, support both simplified (e.g., HMAC-based) and advanced (e.g., ZKP-layered) solutions. Feature-rich wallets necessitate stricter composability guarantees and enables secure data storage and usage analytics.</li> <li>Client compatibility requirements have shifted. In Statligt e-leg, broad app compatibility was needed. The EUDIW model relaxes this constraint and tolerates higher implementation complexity.</li> <li>Certification can now focus solely on the HSM, without addressing external device boundaries.</li> </ul> <p>In summary, a smartphone-centric architecture necessitate updated approaches to key protection, device binding, and recovery to align with certification requirements. Other areas, such as PIN hardening (see Appendix A), remain unaffected.</p>"},{"location":"loa-high-access-mechanism/#22-deployment-context","title":"2.2. Deployment context","text":"<p>To assess candidates, it is helpful to clarify the deployment context.</p> <p>Authentication factors:</p> <ol> <li>The knowledge factor is provided through a trusted UI as a user-controlled PIN, entered on the user device and combined with a device-protected key using PIN hardening. The hardened PIN functions as a client password. Verification occurs server-side to enforce rate-limiting and account locking.  Users are not allowed to set their own PIN.</li> <li>The possession factor is supplied during PIN hardening via a keyed mapping function (e.g., ECDH or HMAC), with the PIN acting as a public input and the key protected by the device\u2019s secure hardware</li> </ol> <p>User device characteristics:</p> <ol> <li>Target platforms are iOS and Android.</li> <li>Trusted component exists and access to secure environment is provided via platform-specific APIs.</li> <li>Devices are BYOD but part of national eID scheme at LoA High where the use of trusted hardware and server request is verified (key attestation, device check etc.).</li> </ol> <p>Protocol parameters:</p> <ol> <li>Standard profiles for threshold signatures (e.g., FROST or MuSig2), or</li> <li>OPAQUE with fresh DH keys and server authentication, configured per test vector 5 (note that PIN-hardening allows us to rely on the identify function as a KSF).</li> </ol> <p>Lifecycle:</p> <ol> <li>Identity proofing is performed per the national eID scheme (out of scope for this document)</li> <li>All attestations are issued with a distinct Proof of Possession key protected by a server-side HSM resource that is gated by the national eID access mechanism described here.</li> <li>Recovery is handled through re-enrollment using the same process as registering the initial user device, associating a new device with the same server-side user account.</li> <li>Validity status is enforced through explicit time periods (e.g., 24-hour validity). No explicit revocation.</li> </ol> <p>Session security:</p> <ol> <li>Post-authentication, all service requests are secured using service specific session keys. These require a second protocol layer when using threshold signatures, but can be directly derived with OPAQUE.  </li> <li>All session keys are specific to the service request. Relatedly, lifetimes are limited to the duration of the individual service request.</li> </ol>"},{"location":"loa-high-access-mechanism/#23-selection-criteria","title":"2.3. Selection criteria","text":"<p>When selecting candidates for further assessment, our disqualifying conditions were:</p> <ol> <li>The candidate must provide security against active adversaries through intrinsic cryptographic guarantees, not through external configurations or assumptions.</li> <li>The candidate must support intrinsic derivation of additional useful cryptographic material as part of the protocol.</li> <li>The candidate must resist offline guessing attacks, even in the event of server-side storage compromise.</li> <li>The protocol must maintain security when composed with other protocols and application logic.</li> <li>The candidate must be widely deployed and tested in a context that makes it suitable for our analysis.</li> </ol>"},{"location":"loa-high-access-mechanism/#24-candidates-for-a-loa-high-access-mechanism","title":"2.4. Candidates for a LoA High access mechanism","text":"<p>Two primary approaches were considered for achieving LoA High compliance: Threshold signatures and password-authenticated key exchange (PAKE). At a glance, the two appear fundamentally different; PAKE gates an HSM-held signing key, while threshold signatures distribute a signing authority. Yet, there are two reasons for the comparison:</p> <ol> <li>Growing support for Schnorr signatures in HSMs enables full user control through distribution of the signing authority.</li> <li>In the NL SCAL 3 initiative, threshold signing functions as the knowledge factor.</li> </ol> <p>Because threshold signing serves as a proof-of-knowledge factor in this context, the comparison is justified.</p> <p>Security assumptions are listed in Appendix B and security goals in Appendix C</p>"},{"location":"loa-high-access-mechanism/#241-threshold-signatures","title":"2.4.1. Threshold signatures","text":"<p>Threshold signature schemes split the signing key among multiple parties, ensuring that a valid signature cannot be generated without collaboration. This enforces cryptographic guarantees of exclusive control, surpassing traditional consent-based mechanisms. Protocols such as FROST and MuSig2 are mature, widely supported, and actively deployed, making them strong candidates for Level of Assurance (LoA) High access mechanisms. Ongoing trials in the Netherlands will serve as the basis for our evaluation.</p> <p>While the cryptographic assurances are compelling, the practical deployment of threshold signature schemes raises several concerns:</p> <ul> <li>Limited deployment. While ECSDSA is listed as a recommended signature scheme in SOG-IS and in ETSI TS 119 312, now expired patent claims have limited its deployment. Threshold signatures are possible also using a variant of Schnorr based on Edwards curves, EdDSA (informational in RFC 8032 and forthcomming in FIPS 186-5). But required curves, like edwards25519 and edwards448, are not included in either SOG-IS, ETSI TS 119 312, and BSI TR 03181 optionally supports edwards25519. The curves are both listed in SP 800-186.</li> <li>Limited HSM support. Outside of IBM HSMs (running in EP11 and CCA mode), hardware support is limited for ECSDSA. Hardware support for EdDSA is better and EdDSA is included in PKCS#11v3.</li> <li>Patent concerns. Using alternatives to Schnorr (and its variants) is not straight forward and can pose significant patent risks.</li> <li>Uncertain compliance implications. Threshold signatures have not yet undergone formal evaluation for compliance with Level of Assurance (LoA) High requirements.</li> <li>Comparatively more complex. Theoretical benefits (e.g., recovery) require complex multi-party setups and may offer limited advantages over simpler approaches, which benefit from existing experience and reusable components (e.g., re-onboarding).</li> <li>Extension requirement. A threshold signature scheme needs to be extended and tailor to the intended application (e.g., access mechanism or PoP). This burdens the security analysis.</li> </ul> <p>Using ECSDSA is challenging and restricts implementation flexibility and increases both vendor dependency and legal risk. Hardware support for EdDSA is much better, but it lags behind in European standardization. </p> <p>Even if these barriers are overcome, the unproven compliance status and added complexity diminish the overall value proposition. Without clear and substantial benefits, adopting threshold signatures remains difficult to justify.</p> <p>Furthermore, the specific application of threshold signatures must be defined. An intuitive assumption is their use to distribute signing authority for the PoP. But upon closer scrutiny, the benefits of such an application today seem unclear. While threshold signatures enforce multi-party control over signing, there is no mechanism to enforce their use. Since group signatures are syntactically indistinguishable from single-party signatures, demonstrating user control over the PoP key requires additional assurances.</p> <p>Note that distributing the PoP key via threshold signing is unrelated to the access mechanism itself. We address this application only because it is a common assumption about threshold signing in general. When threshold signing is used for PoP key control, a separate access mechanism is still required to authenticate the user.</p> <p>These assurances can take various forms. One option is to use transcript proofs to verify threshold participation. While they do not enforce policy, they make violations publicly detectable. The Cleverbase approach leverages FROST\u2019s native support for transcript proofs to provide this assurance. An alternative is to rely on a trusted key dealer who generates and distributes shares and issues a signed statement confirming that the public key is a threshold key. But this undermines the sole control model, as the trusted dealer learns all signing shares. If the dealer is trusted with these shares, it is simpler delegate the signing operation entirely to that trust domain.</p> <p>Finally, even if all challenges are resolved, there remains a critical gap: no current verifier support for ECSDSA among Relying Parties. EdDSA is a stronger candidate in this regard and once European standardization matures, it is the more obvious candidate.</p> <p>In practice, threshold signatures appear ill-suited for distributing the PoP key. Unsurprisingly, this is not the application explored in the Cleverbase proposal. The Cleverbase proposal employs threshold signatures as part of the second factor in a Level of Assurance (LoA) High authentication. The user functions as a trusted key dealer, generating the threshold key shares. The user's share is encrypted with a hardened PIN, while the server's share is encrypted with an HSM protected key. The server binds the group public key to the user.</p> <p>During authentication, the server first verifies the possession factor, then uses FROST to compute a threshold signature on a session-specific challenge, thereby verifying the second factor. This effectively gates HSM access behind a LoA High two-factor authentication.</p> <p>While this is an innovative use of threshold signatures, it raises one key question:</p> <p>Threshold cryptography is meaningful only when control over the signing process and the protected resource are independently distributed. If only the signing process is distributed, but not the protected resource (e.g., the server uses threshold signatures to gate an HSM-protected signing key) then what does threshold signing achieve?</p> <p>Our analysis could not answer this question when considering a EUDIW Provider context.</p> <p>Let Sander have a stab at providing an answer. One argument is accountability increases with the public transcript proof. This clarifies the separation between the Authorization server and the Resource Server.</p>"},{"location":"loa-high-access-mechanism/#242-password-authenticated-key-exchange","title":"2.4.2. Password Authenticated Key Exchange","text":"<p>PAKE protocols enable secure mutual authentication over untrusted networks without transmitting passwords in cleartext. They are typically categorized as:</p> <ol> <li>Balanced PAKE (bPAKE): Client and server share a password.</li> <li>Augmented PAKE (aPAKE): Server stores a verifier.</li> </ol> <p>Similar to threshold cryptography, aPAKE methods enhance security by mitigating the impact of server compromise, as no plaintext-equivalent credentials are stored. They also prevent offline attacks by requiring active server participation in the authentication process.</p> <p>Among various aPAKE protocols (compared here), OPAQUE stands out as the only one with both a mature standard and a formal security proof under the Universal Composability (UC) framework. Its properties have been previously analyzed in the \"Statliga e-leg\" section on OPRF-based aPAKE. OPAQUE's UC security model enables safe protocol composition, reducing the need for separate security analyses and minimizing the risk of implementation flaws. This makes it particularly suitable for high-assurance environments where server compromise or insider threats are significant concerns.</p> <p>In sum, key practical benefits of aPAKE:</p> <ol> <li>Enhances server-side credential security by eliminating stored plaintext-equivalent data.</li> <li>Limits attacks by requiring online interaction with the server.</li> <li>Supports secure integration with layered protocols, simplifying overall system security evaluation.</li> <li>Outputs a shared key useful for other applications.</li> </ol> <p>Given our analysis of both threshold signatures and PAKE as candidates for an LoA High access mechanism, we focus the remainder of this text on detailing an aPAKE-based approach.</p>"},{"location":"loa-high-access-mechanism/#3-an-apake-based-access-mechanism","title":"3. An aPAKE-based access mechanism","text":"<p>We outline an enveloping protocol to establish a secure channel between a user's smartphone (a BYOD device) and a protected server (hosting resources such as an HSM, storage, and logging etc).</p> <p>The primary function of this protocol is to enable secure use of an HSM-protected EUDIW private key from a mobile device. The protocol provides end-to-end confidentiality, forward secrecy, and mutual authentication of exchanged data. It also facilitates server-side management of a secret key used for client-side encryption.</p> <p>After key exchange, subsequent secure communications between smartphone and server can reuse the derived session keys. This reuse does not compromise security, due to the UC security guarantees provided by OPAQUE.</p>"},{"location":"loa-high-access-mechanism/#31-high-level-protocol-steps","title":"3.1. High-level protocol steps","text":"<p>The protocol details have previously been analyzed in the Statliga e-leg project with an implementation available here (c.f., also the IETF datatracker). Below is a high-level overview:</p> <pre><code>+--------+        +-------------+        +--------+        +--------+\n|  User  |        |   Device    |        | Server |        |  HSM   |\n+--------+        +-------------+        +--------+        +--------+\n    |                   |                    |                   |\n    | 1. Enters PIN ----&gt;                    |                   |\n    |                   |                    |                   |\n    |                   | 2. PIN Hardening   |                   |\n    |                   |  (keyed function)  |                   |\n    |                   |                    |                   |\n    |                   | 3. Derive PAKE pwd |                   |\n    |                   |                    |                   |\n    |                   |&lt;==================&gt;|                   |\n    |                   | 4. aPAKE exchange  |                   |\n    |                   |  Auth + Secure     |                   |\n    |                   |  Session Setup     |                   |\n    |                   |  Output: client    |                   |\n    |                   |  key pair, session |                   |\n    |                   |  key, storage key  |                   |\n    |                   |                    |----&gt; Request ----&gt;|\n    |                   |                    |  keyed function   |\n    |                   |                    |&lt;---- Response ----|\n    |                   |&lt;==================&gt;|                   |\n    |                   |                    |                   |\n    |                   | 5. Service Request |                   |\n    |                   |-------------------&gt;|                   |\n    |                   | 6. Service Response|                   |\n    |                   |&lt;-------------------|                   |\n</code></pre> <p>The exchange comprises three phases:</p> <ol> <li>Activation: The user activates their device by entering a PIN (knowledge factor), which is combined with a secure element-protected key (possession factor) to meet the LoA High two-factor authentication requirement, as detailed in Appendix A.</li> <li>Key exchange: The device derives an aPAKE password (containing both their knowledge and possession factor) and establishes a mutually authenticated, confidential session with the server. This session produces a session key for encrypted communication and an optional storage key for server-side encrypted storage.</li> <li>Service provisioning: All subsequent interactions are secured using the aPAKE-derived session keys.</li> </ol> <p>The activation process aligns with the User Authentication flow detailed in the \"Statligt e-leg\" report, though simplified due to smartphone capabilities.</p> <p>Expected service requests during the provisioning phase include:</p> <ol> <li>Operations using the HSM-protected private key.</li> <li>Storage or retrieval of data encrypted under the storage key.</li> <li>Reporting usage metrics for aggregation.</li> </ol> <p>The second and third are added with the increased reliance on smartphones.</p>"},{"location":"loa-high-access-mechanism/#appendices","title":"Appendices","text":""},{"location":"loa-high-access-mechanism/#appendix-a-pin-hardening","title":"Appendix A: PIN-hardening","text":"<p>The knowledge factor builds on the PIN-hardening approach defined in the technical specifications for the \"Statligt e-leg.\" Hardening serves two primary purposes:</p> <ol> <li>It enforces two-factor authentication by combining the possession factor (a device-specific secret) with the knowledge factor (the PIN) to form a composite password.</li> <li>It compensates for the inherently low entropy of random \\(n\\)-digit PINs (bit security normally ranges between ~2.3 - 20 and depends chiefly on PIN length and whether or not the PIN is user selected).</li> </ol> <p>Note: Hardening differs from traditional key-stretching or strengthening via a KDF. Instead, it fuses the PIN with a hardware-protected, device-specific key.</p> <p>The user device maintains a set of keyed mapping functions (e.g., HMAC, ECDSA, ECDH) that can harden the PIN. This process binds the two authentication factors and increases overall entropy by incorporating the device-resident key.</p> <p>With smartphone-based implementations, the previously defined PIN-hardening method can be simplified (see, e.g., Signal\u2019s secure value recovery). Specifically, access to HMAC allows bypassing the need to map the PIN to a random elliptic curve point for ECDH. Nonetheless, server-side rate limiting remains essential to defend against brute-force attacks.</p> <p>Platform support for key derivation functions (KDFs) is inconsistent: iOS supports HKDF, while Android's support is less clear. Given both platforms support HMAC, and considering the specific use case, HMAC alone may suffice without introducing an additional KDF layer.</p> <p>Stefan: As we will implement OPAQUE, we will need hash2Curve anyway. But that is not a problem because a) we have working implementations for both iPhone and Java, and b) we no longer need to support easy creation of custom clients. This means that the complexity of this is negligeble compared to the total development effort. I still think the strongest proposal is <code>HKDF(DH(walletPrivate, H2C(PIN)))</code></p>"},{"location":"loa-high-access-mechanism/#appendix-b-security-assumptions","title":"Appendix B: Security assumptions","text":"<ol> <li>Secure hardware</li> <li>Smartphones are equipped with secure elements and/or TEE, providing access to cryptographically secure keyed mapping functions like HMAC, various KDFs, and/or ECDH.</li> <li>The server with a certified HSM supports HPKE-based KEM, OPRF, Argon2, and MAC operations. It can also store user-specific rate counters and cryptograms.</li> </ol> <p>Stefan: Server based HSM operations can be reduced to Diffie-Hellman operations and client key generation.</p> <ol> <li>Adversaries</li> <li>perform active network attacks, replay messages, and intercept all traffic.</li> <li>gain software-level access to the server, but not extract key material from the HSM.</li> <li>extract the TEE image and encrypted data from a client device but not bypass hardware protected keys.</li> </ol>"},{"location":"loa-high-access-mechanism/#appendix-c-security-goals-and-opaque","title":"Appendix C: Security goals and OPAQUE","text":"Goal Description OPAQUE Security Analysis G1 Each attack attempt requires online interaction. Achieved through rate-limited online interactions. G2 Two-factor assurance. PIN hardening implemented using the smartphone secure element. G3 Hardware protected keys. PIN-hardened key protected by secure enclave; OPRF key protected by HSM. G4 Attackers must not trivially exhaust server-side rate limits. Possible via exponential backoff and authenticated requests. G5 Protect user's PIN even if the server is compromised. No password material is ever sent to the server. <p>The above list is not complete, it only highlights assumptions and requirements relevant for the current evaluation.</p>"},{"location":"onboarding/","title":"Wallet Onboarding Flow","text":"<p>Status: Draft</p> <p>Executive summary: This document describes the onboarding flow for the digital identity wallet, which uses two-factor authentication: a hardware-backed device key (possession) and a PIN (knowledge). The Wallet Provider verifies both and links them to an HSM key. User identification and PID issuance are handled separately by the PID Provider. The flow supports critical functions (e.g., revocation) even if all devices are lost.</p>"},{"location":"onboarding/#problem-statement-and-desired-outcome","title":"Problem Statement and Desired Outcome","text":"<p>A digital identity wallet must establish two-factor authentication to support high-assurance operations. The possession factor is a hardware-protected device key, with attestation confirming it is stored in tamper-resistant hardware. The knowledge factor is a user-chosen PIN, registered via an augmented PAKE protocol (OPAQUE).</p> <p>The Wallet Provider requires a user account to enable certain wallet functionality. Crucially, the Wallet Provider verifies both authentication factors, and then generates a distinct HSM-protected signing key for that wallet device.</p> <p>The result is a registered wallet instance with an HSM-protected signing key associated with both authentication factors and a Wallet Unit Attestation (WUA) that can be presented to attestation issuers. A user account may be linked to multiple wallet devices (account creating and management are out of scope).</p> <p>The onboarding flow supports a range of privacy-preserving wallet features, including revocation if all of a user's registered devices are lost.</p>"},{"location":"onboarding/#success-criteria","title":"Success Criteria","text":"<p>Onboarding is successful when the following criteria are met:</p> <ol> <li>The possession factor is registered with the Wallet Provider.</li> <li>The knowledge factor is registered with the Wallet Provider.</li> <li>An HSM-protected signing key is generated and stored in the user's wallet account.</li> <li>An WUA containing the HSM-protected signing key is issued to the device.</li> <li>The device is ready to obtain a PID.</li> <li>Revocation mechanisms are established that do not depend on user access to the wallet account.</li> </ol> <p>Note 1: The WUA provides cryptographic proof to the PID Provider that the PoP key (i.e., the HSM-protected key) is protected by two-factor authentication verified by the Wallet Provider, establishing the Level of Assurance required for PID issuance.</p> <p>Note 2: The Wallet Provider verifies both authentication factors and attests to their validity. The PID Provider identifies the user and associates this identification with the HSM-protected PoP key.</p> <p>Note 3: The revocation mechanism established during onboarding complements other mechanisms available when the user retains access to their wallet account (not detailed herein).</p>"},{"location":"onboarding/#design-decision-drivers-and-requirements","title":"Design Decision, Drivers, and Requirements","text":"<p>The following decision drivers apply:</p> <ul> <li>The Wallet Provider MUST NOT learn the user\u2019s real-world identity during onboarding or wallet operations, even if this necessitates additional steps or responsibilities.</li> <li>For LoA High, the wallet MUST establish two independent authentication factors: possession (hardware-protected device key) and knowledge (PIN).</li> <li>Device keys MUST be hardware-backed with verifiable proof of tamper-resistant storage.</li> <li>To limit breach impact and protect privacy, registration MUST prevent the Wallet Provider from learning the PIN and attackers from accessing any usable user data.</li> <li>PIN registration MUST occur over a secure session initiated with the device key to bind possession and knowledge factors.</li> <li>Users MUST NOT be required to remember or store any information beyond their PIN for onboarding or subsequent wallet operations.</li> <li>The solution MUST support multiple devices per user, with each device having independent possession and knowledge factors and distinct HSM-protected signing keys.</li> </ul> <p>Note: Previously, we considered supporting multiple devices per wallet instance. However, this requires a cloud-based wallet and adds complexity. A simpler, architecture-agnostic approach is to allow only one device per wallet instance. The PID Provider may impose additional limits on how many instances receive a PID.</p>"},{"location":"onboarding/#scope-and-related-documentation","title":"Scope and Related Documentation","text":"<p>This document describes the initial wallet onboarding flow for a user's first device. The following scenarios are excluded from this document and will be covered separately:</p> <ul> <li> <p>Adding Additional Devices: Authorizing a new device when a user already has a registered wallet.</p> </li> <li> <p>Revocation Scenarios: Methods for revoking wallet instances when all devices are lost, stolen, or compromised, and the user cannot access their wallet account.</p> </li> <li> <p>Wallet Recovery: Mechanisms for recovering wallet access after device loss.</p> </li> <li> <p>Attestation (Re-)Issuance: Obtaining attestations beyond the initial issuance of the WUA.</p> </li> </ul>"},{"location":"onboarding/#onboarding-flow","title":"Onboarding Flow","text":"<p>This section outlines the wallet onboarding process from the device perspective, with a sequence diagram followed by step-by-step descriptions.</p>"},{"location":"onboarding/#overview","title":"Overview","text":"<p>Onboarding consists of the following steps (happy path):</p> <ol> <li>The user installs the Wallet App and opens it for the first time.</li> <li>Device generates a hardware-protected key pair and obtains a key attestation.</li> <li>The device registers with the Wallet Provider, which triggers account creation (out of scope).</li> <li>The Wallet Provider issues a WUA after completing the following:<ul> <li>Cloud wallet: The device registers a PIN with the Wallet Provider over a secure session initiated using the device key (cf. OPAQUE). The Wallet Provider then generates an HSM-protected signing key and links it to the user account.</li> <li>Mobile wallet: The Wallet Provider accepts the device key as the hardware-protected signing key, based on a key attestation confirming the required security level and user authentication(cf. StrongBox and Secure Enclave for details).</li> </ul> </li> <li>The Wallet Provider issues a WUA containing the hardware-protected signing key. The wallet device is now ready to request a PID.</li> </ol>"},{"location":"onboarding/#sequence-diagram","title":"Sequence Diagram","text":"<p>The following sequence diagram illustrates the complete onboarding flow with a focus on a cloud-wallet (happy path). The diagram shows also the required delegation of the revocation authorization.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant User\n    participant Wallet as Wallet App/Device\n    participant WP as Wallet Provider\n    participant HSM\n    participant RA as Revocation Agent\n\n\n    User-&gt;&gt;Wallet: Install and open Wallet App\n    Wallet-&gt;&gt;Wallet: Generate hardware-protected key pair\n    Wallet-&gt;&gt;Wallet: Generate key attestation\n    Wallet-&gt;&gt;Wallet: Generate signed integrity token&lt;br&gt;(Play Integrity API / DeviceCheck and App Attest)\n\n    Wallet-&gt;&gt;Wallet: Create and sign account&lt;br&gt;registration request\n    Wallet-&gt;&gt;WP: Account registration request    \n    WP-&gt;&gt;WP: Verify integrity token\n    WP-&gt;&gt;WP: Verify possession factor using key attestation\n    WP-&gt;&gt;WP: Create user account\n    WP-&gt;&gt;WP: Register possession factor\n    WP-&gt;&gt;Wallet: Account registration response\n\n    alt Native wallet\n        WP-&gt;&gt;WP: Verify second factor using key attestation\n    else Cloud-HSM\n        Wallet-&gt;&gt;User: Prompt for PIN\n        User-&gt;&gt;Wallet: Enter PIN\n        Wallet-&gt;&gt;Wallet: Apply PIN hardening\n        Wallet-&gt;&gt;WP: OPAQUE PIN registration request (using device key)\n        WP-&gt;&gt;Wallet: OPAQUE registration response\n        Wallet-&gt;&gt;WP: Complete OPAQUE exchange\n        WP-&gt;&gt;WP: Register knowledge factor\n        WP-&gt;&gt;HSM: Request signing key generation\n        HSM-&gt;&gt;HSM: Generate key pair\n        HSM-&gt;&gt;WP: Return key envelope\n        WP-&gt;&gt;WP: Bind key envelope to user account\n    end\n\n    WP-&gt;&gt;WP: Create signed WUA\n    WP-&gt;&gt;Wallet: WUA\n    Wallet-&gt;&gt;Wallet: Store WUA\n\n    Note over User,HSM: Wallet is now ready for use\n\n    opt Support revocation if all account access is lost\n        RA-&gt;&gt;Wallet: Authorization request redirect\n        Wallet-&gt;WP: Authentication\n        WP-&gt;&gt;Wallet: Request consent\n        Wallet-&gt;&gt;User: Present consent prompt\n        User-&gt;&gt;Wallet: Accept\n        Wallet-&gt;&gt;WP: Reply with consent accept\n        WP-&gt;&gt;WP: Create grant record\n        WP-&gt;&gt;Wallet: Authorization response redirect with auth code\n        Wallet-&gt;&gt;RA: Auth code\n        RA-&gt;&gt;WP: Auth code\n        WP-&gt;&gt;WP: Validate\n        WP-&gt;&gt;RA: Refresh + Access token\n        RA-&gt;&gt;RA: Token storage\n    end\n\n    Note over User,RA: Wallet is now fully onboarded</code></pre>"},{"location":"onboarding/#steps-1-4-wallet-app-install-and-initiation","title":"Steps 1-4: Wallet App Install and Initiation","text":"<p>The user downloads and installs the Wallet App on their wallet device, then launches it to begin initialization.</p> <p>User Action: - Complete Wallet App initialization steps (details out of scope).</p> <p>Device Action: - Generates a hardware-protected asymmetric key pair. - Generates an associated key attestation. - Generate integrity token (platform specific) </p> <p>Note: The specifics of key attestation and the intended use of the device key depend on the certification state of the user's device. A non-certified device requires a cloud wallet, where the device key functions as a context key for authenticated communication with the cloud wallet operator.</p>"},{"location":"onboarding/#steps-5-11-account-creation-and-device-registration","title":"Steps 5-11: Account Creation and Device Registration","text":"<p>The device initiates device account registration with the Wallet Provider, submits the required information, and receives a registration completion notification.</p> <p>Device Action: - Device prepares and submits an account registration request to the Wallet Provider containing:   - Device integrity assurances from Step 4.   - Device key attestation from Step 3.</p> <p>Wallet Provider Actions: - Verifies integrity token. - Verifies key attestation. - Creates user account. - Registers the possession factor. - Confirms account registration.</p>"},{"location":"onboarding/#steps-12-26-second-factor-check-and-wua-issuance","title":"Steps 12-26: Second Factor Check and WUA Issuance","text":"<p>Following device registration, the Wallet Provider has two options. </p> <p>If key attestation and integrity checks originate from a certified EUDIW device, the Wallet Provider can verify second-factor control using the key attestation alone (Step 12). In this case, in Step 2, the device has already gated access to the signing key behind a second factor.</p> <p>If not, Steps 13\u201323 cover prompting the user for a PIN, registering it server-side using OPAQUE, generating the user's HSM-protected signing key, and exporting and associating the key envelope with the user account.</p> <p>In either case, once the Wallet Provider has confirmed two-factor control and obtained assurance of a hardware-protected key, it creates and signs a WUA, which it then issues to the Wallet App. The user can then request, for example, a PID.</p>"},{"location":"onboarding/#steps-27-39-delegated-revocation-authority-with-oauth-20","title":"Steps 27-39: Delegated Revocation Authority with OAuth 2.0","text":"<p>To support revocation when a user loses access to their wallet account, a privacy-preserving fallback is required. Normally, users manage devices and recovery via their wallet account, but loss of access necessitates an alternative.</p> <p>The solution delegates revocation authority to a Revocation Agent during initial onboarding. Once a WUA is issued, the wallet visits a Revocation Agent and initiates with the delegation setup. Later, the user can authenticate to the Revocation Agent, who exchanges their refresh token for an access token. The access token is then submitted to the Wallet Provider's revocation endpoint to complete the revocation.</p> <p>This approach also covers cases where the Wallet Provider revokes the WUA and must notify the user via a channel other than the wallet device (per TS3 and HLR requirements). The Wallet Provider can reference the delegation token and forward the revocation notice to the designated Revocation Agent.</p> <p>For details on the delegated revocation, see revocation.md</p>"},{"location":"revocation-noaccess/","title":"Revocation When All Devices Are Lost","text":"<p>Status: Ready for internal review</p> <p>Executive summary: This text introduces two revocation approaches that enable a user to revoke their wallet instance(s). These approaches do not require the wallet provider to learn the user's identity or the user to retain control of any existing wallet device or authentication device. The first method uses pseudonymous authentication. The second (recommended method), delegates revocation authority.</p>"},{"location":"revocation-noaccess/#problem-statement-and-desired-outcome","title":"Problem Statement and Desired Outcome","text":"<p>A user may lose access to all wallet devices. If an attacker gains control of one and bypasses local authentication, they can impersonate the user or misuse attestations. Therefore, users must be able to disable wallet functionality without access to any existing wallet device or account.</p> <p>For privacy, the entity observing wallet usage (e.g., via HSM access) should not know the user's identity. Centralizing identity and usage data creates a high-value target: if breached alongside a sensitive service (e.g., age verification for adult content), an attacker could link users to sensitive activity and exploit that for extortion. Separating identity and usage across entities limits the impact of such breaches.</p> <p>Users may also wish to disable wallet functionality either temporarily (suspension) or permanently (revocation). Accordingly, revocation mechanisms must prevent unauthorized use, preserve user anonymity, and support varying assurance levels for reversible and irreversible actions.</p> <p>This text focuses solely on the revocation trigger. Details of the revocation process (such as whether a revoked wallet enters a suspension period to prevent unauthorized use) are out of scope.</p> <p>This document defines success criteria and decision drivers, and uses them to develop two revocation approaches that function when all devices are lost.</p>"},{"location":"revocation-noaccess/#success-criteria","title":"Success Criteria","text":"<p>Success is defined as disabling the Wallet Instance, either temporarily (suspension) or permanently (revocation). In the case of permanent revocation, two things occur:</p> <ol> <li>No new WUAs are issued, preventing an attacker from obtaining new attestations where issuance depends on a valid WUA.</li> <li>If necessary, existing WUAs are revoked. The associated wallet identifier is added to a public revocation list. This serves as a notification mechanism, enabling issuers to take appropriate action if they have issued attestations to that identifier. This also prevents attackers from using still-valid attestations contained within the compromised wallet.</li> <li>Revocation is made with the consent of the legitimate wallet owner in a way that honors the wallet owner's prioritization between the risk of unauthorized revocation and the risk of failing to revoke a compromised wallet instance.</li> </ol> <p>Issuers are not prescribed a specific method for revocation or revalidation; each MUST adopt mechanisms aligned with their threat model and privacy requirements.</p>"},{"location":"revocation-noaccess/#decision-drivers","title":"Decision Drivers","text":"<p>The following decision drivers apply:</p> <ul> <li>The solution MUST NOT enable any party involved in revocation to correlate a user's real-world identity with wallet usage, even if achieving this requires new roles or novel mechanisms.</li> <li>Revocation requests MUST be explicitly authorized, scoped, and verifiable.</li> <li>Reversible actions, such as temporary suspension, MUST be executable at a lower level of assurance to enable a timely response to device loss even if initiated under uncertainty.</li> <li>Irreversible actions, such as permanent revocation, MUST require a substantial level of assurance and demonstrable authorization.</li> <li>The solution MUST be adaptable to user preferences, enabling options aligned with priorities such as misuse prevention and revocation accessibility.</li> </ul> <p>The following sections describe two complementary approaches for enabling users who have lost all devices to request revocation of existing wallet instances. The first approach relies on a pseudonym seed issued by the PID provider and can be used if the user enrolls a new PID after device loss.</p> <p>The second approach delegates revocation authority through a revocation token, allowing revocation without requiring PID re-enrollment. Two implementation options are proposed.</p>"},{"location":"revocation-noaccess/#revocation-approach-1-pseudonymous-revocation","title":"Revocation Approach 1: Pseudonymous Revocation","text":"<p>The pseudonym-based revocation approach allows a user to authenticate using a pseudonym to request revocation. A pseudonym manager is required to issue the pseudonym. Ideally, this is the PID Provider, who can embed a pseudonym seed or disclosable pseudonyms in the PID.</p> <p>This method is useful when a user has lost all previous devices but has acquired a new one and enrolled a new PID, without explicitly revoking the old devices. It complements other revocation mechanisms.</p>"},{"location":"revocation-noaccess/#pseudonymous-authentication","title":"Pseudonymous Authentication","text":"<p>The approach requires pseudonymous authentication. Instead of authenticating with an existing wallet device, the user is authorized to perform revocation by disclosing a pseudonym derived from a valid PID. This requires two elements:</p> <ol> <li>A deterministic pseudonym; ideally managed by the PID Provider, who can embed a pseudonym seed or disclosable pseudonyms in the PID.</li> <li>The user must obtain a new PID.</li> </ol> <p>Although seed generation is out of scope for this document, a simple method is to apply a keyed mapping function (e.g., HMAC) to existing PID data. A high-entropy random source is required to ensure the seed is not guessable.</p> <p>Revocation is triggered when the user enrolls a new wallet without demonstrating linkage to an existing one. During enrollment, the PID provider authenticates the user and includes the pseudonym seed in the PID. The wallet presents this seed to the wallet provider, which detects an existing account with the same seed. The user is then asked whether they still have access to any of the previous devices. If so, they must prove control of one device to add the new one to their existing wallet account. If not, the existing devices are revoked, and the new device becomes the sole active instance.</p> <p>If the user has control of at least one device, they do not need the revocation approach detailed herein.</p>"},{"location":"revocation-noaccess/#revocation-approach-2-delegated-revocation","title":"Revocation Approach 2: Delegated Revocation","text":"<p>A delegation-based revocation approach allows a user to appoint a revocation agent to act on its behalf. The method is particularly useful when users lose access to all their devices and has not enrolled a new PID. It is intended to complement other revocation mechanisms.</p> <p>Two options are presented, sharing the following commonalities:</p> <ol> <li>Both are modeled as delegated revocation authority.</li> <li>Both separate revocation into two phases. A delegation setup is performed while the user has access to their wallet device and account, and delegation use is invoked after the user has lost access to both.</li> <li>Both allow the user to choose whether to prioritize misuse prevention or revocation accessibility.</li> </ol> <p>The next sections first explain the main idea behind delegating revocation authority. This is followed by a brief introduction to the two revocation phases. Finally, two implementation options are discussed.</p>"},{"location":"revocation-noaccess/#delegated-revocation-authority","title":"Delegated Revocation Authority","text":"<p>The delegated revocation approach models revocation authorization as a delegated authority, \\((x, r, c)\\), where \\(x\\) identifies a specific wallet instance, \\(r\\) defines the rights and \\(c\\) defines the conditions that must be met to exercise the rights. Rights are typically the right to do reversible suspension or irreversible revocation of \\(x\\) and the condition \\(c\\) defines conditions such as the level of wallet holder authentication and consent that is required at the time of revocation to perform an authorized action. This authority is explicitly delegated by the wallet user through a signed authorization artifact.</p> <p>The artifact binds revocation rights to a designated revocation agent by including the agent\u2019s public key as an attribute. Possession of the corresponding private key proves control over the delegated revocation authority.</p> <p>Revocation requires both a proof of the delegation, and a proof of key possession. Authorization is derived from explicit delegation rather than from authentication of the requester as the wallet holder.</p> <p>While the wallet holder is not authenticated to the Wallet Provider at revocation time, they must authenticate to the revocation agent to trigger execution of the delegated authority. This authentication uses any method supported by the agent that is consistent with the agreed conditions, \\(c\\), and may therefore occur at a lower assurance level than the initial delegation. The WP does not rely on this authentication step; authorization is based solely on the delegation and proof of key control, but the agent must attest that the relevant condition(s) has been met for the requested revocation action. In practice this could mean that it can be agreed that the condition for temporary blockage is met by a simple telephone call with only basic account verification checks, while permanent revocation requires stronger authentication means.</p> <p>The following sections detail the token used to delegate revocation authority and the two tokens included in enabling a delegated revocation request.</p>"},{"location":"revocation-noaccess/#delegation-setup-and-delegation-use","title":"Delegation Setup and Delegation Use","text":"<p>This approach follows a similar model to escrowed revocation certificates in OpenPGP escrowed revocation certificates, by splitting revocation into two distinct phases. In the delegation setup phase, the user (while still in control of their wallet instance) explicitly delegates revocation authority to a designated agent. This high-assurance process results in the creation of a delegation token (Implementation Option 1) or a grant at the Authorization Server (Implementation Option 2).</p> <p>In the subsequent delegation use phase, the revocation agent operates independently to submit revocation requests to the WP's revocation endpoint using a sender-constrained access token. The assurance level required for this phase can be configured by the user, depending on whether they prioritize misuse prevention or availability in emergency situations.</p> <p>Next, the two implementation options are presented.</p>"},{"location":"revocation-noaccess/#implementation-option-1-delegation-revocation-tokens","title":"Implementation Option 1: Delegation + Revocation Tokens","text":"<p>This option uses two tokens to establish a chain of delegated authority: a delegation token that conveys revocation rights from the user to a revocation agent, and a revocation token that exercises those rights. These tokens are submitted to a REST API that the WP exposes for this purpose.</p>"},{"location":"revocation-noaccess/#delegation-token","title":"Delegation Token","text":"<p>The delegation token is a user-signed authorization artifact that conveys delegated authority to revoke a specific wallet.</p> <p>It is implemented as a JWS, created by the wallet while the user still retains control.</p> <p>JWS Header</p> <pre><code>{\n  \"alg\": \"ES256\",\n  \"typ\": \"delegation+jwt\",\n  \"jwk\": \"&lt;wallet public key&gt;\"\n}\n</code></pre> <p>The JWS Header contains information to validate the type of the token and the JWS payload. Note that the Wallet Provider is assumed to know the mapping between a wallet identifier and the wallet public key in the <code>jwk</code>.</p> <p>JWS Payload</p> <pre><code>{\n  \"wid\": \"&lt;wallet identifier as contained in the WUA&gt;\",\n  \"r\": [\"revocation\", \"suspension\", ...],\n  \"cnf\": {\"&lt;revocation agent public key&gt;\"},\n  \"iat\": 1516239022,\n  \"exp\": 1526239022\n}\n</code></pre> <p>The JWS payload contains information about the wallet identifier, <code>wid</code>, the delegated rights, <code>r</code>, and the revocation agent public key in <code>cnf</code>. It also contains explicit issuance and validity dates.</p>"},{"location":"revocation-noaccess/#revocation-token","title":"Revocation Token","text":"<p>The revocation token is signed by the revocation agent and allows the Wallet Provider to derive the revocation authorization from a delegation.</p> <p>JWS Header</p> <pre><code>{\n  \"alg\": \"ES256\",\n  \"typ\": \"wallet-revocation+jwt\",\n  \"jwk\": \"&lt;revocation agent cnf key&gt;\"\n}\n</code></pre> <p>The JWS Header contains information to validate the type of the token and the JWS payload. Note that the Wallet Provider needs to check that the <code>jwk</code> matches the delegation in the payload.</p> <p>JWS Payload</p> <pre><code>{\n\n  \"act\": \"revocation\",\n  \"wid\": \"&lt;wallet identifier as contained in the WUA&gt;\",\n  \"dt\": {\"&lt;delegation token&gt;\"},  \n  \"iat\": 1516239022,\n  \"exp\": 1526239022\n}\n</code></pre> <p>The JWS payload conveys both the intended action (act) and the wallet identifier (wid). It also embeds the delegation token under the <code>dt</code> attribute, allowing the Wallet Provider to derive the authorization right for the specified action.</p>"},{"location":"revocation-noaccess/#implementation-option-2-oauth-20","title":"Implementation Option 2: OAuth 2.0","text":"<p>This option uses OAuth 2.0 to delegate revocation authority from a user to a revocation agent. The revocation agent is authorized to obtain sender-constrained access tokens, which it can later present to a revocation endpoint exposed by the Wallet Provider (WP).</p>"},{"location":"revocation-noaccess/#delegation-setup","title":"Delegation Setup","text":"<p>During a period in which the user has control over their device and user account, the user may delegate revocation authority to a revocation agent. Each revocation agent is registered with the WP\u2019s Authorization Server (AS) and is assigned a unique <code>client_id</code>. The agent authenticates to the AS using a registered public key (e.g., via <code>private_key_jwt</code>).</p> <p>Delegation is established using a standard OAuth 2.0 Authorization Code flow with PKCE. The user explicitly authorizes the revocation agent to perform revocation-related operations on a specific wallet instance under defined conditions. This authorization is recorded as a grant at the AS and is bound to: - the revocation agent (client), - the permitted operations (scopes), - the identified wallet instance (resource), and - the conditions that must be met for each operation (as agreed with the user)</p> <p>As long as this grant remains valid, the revocation agent may use an associated refresh token to obtain sender-constrained access tokens. Sender constraint is achieved using DPoP, binding issued tokens to a proof-of-possession key controlled by the revocation agent instance.</p> <p>The Delegation Setup has the following steps:</p> <ol> <li> <p>User initiates delegation    The user visits the revocation agent.</p> </li> <li> <p>Authorization request    The revocation agent redirects the user to the WP\u2019s Authorization Server with an authorization request that:</p> </li> <li>uses the Authorization Code grant,</li> <li>includes PKCE parameters,</li> <li>requests revocation-related scope(s),</li> <li>identifies the wallet instance as the target resource, and</li> <li>identifies the conditions required to exercise each scope.</li> </ol> <p><code>http    GET https://wp.example.com/authorize?        response_type=code&amp;        client_id=revocation_agent_123&amp;        scope=wallet.revoke+wallet.suspend&amp;        revocation_conditions=wallet.revoke.permanent:c_high, wallet.block.temporary:c_low&amp;        resource=https://wp.example.com/revoke&amp;        redirect_uri=https://revocation-agent.example.com/callback&amp;        code_challenge=...&amp;        code_challenge_method=S256&amp;        state=&lt;random_state&gt;</code></p> <ol> <li> <p>User authentication    The user authenticates to the Authorization Server.</p> </li> <li> <p>Consent    The Authorization Server presents a consent screen describing the delegated revocation rights and the affected wallet instance.</p> </li> <li> <p>Authorization grant    The user approves the delegation. This results in a grant record authorizing the revocation agent for the specified wallet instance.</p> </li> <li> <p>Authorization response    The Authorization Server redirects the user back to the revocation agent with an authorization code.</p> </li> </ol> <pre><code>GET https://revocation-agent.example.com/callback?\n    code=&lt;authorization_code&gt;&amp;\n    state=&lt;same_state&gt;\n</code></pre> <ol> <li>Token exchange    The revocation agent exchanges the authorization code for tokens at the token endpoint.    The request is form-encoded, authenticates the client, and includes the DPoP proof.</li> </ol> <pre><code>POST /token\nContent-Type: application/x-www-form-urlencoded\nDPoP: &lt;DPoP_JWT_signed_with_instance_key&gt;\n\ngrant_type=authorization_code&amp;\ncode=AUTH_CODE_xyz123&amp;\nredirect_uri=https://revocation-agent.example.com/callback&amp;\nclient_id=revocation_agent_123&amp;\ncode_verifier=...&amp;\nclient_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&amp;\nclient_assertion=&lt;signed_JWT&gt;\n</code></pre> <ol> <li>Refresh token storage    The revocation agent stores the refresh token securely for future use. Subsequent access tokens obtained via the refresh token are also DPoP-bound. The user can revoke delegation via the WP\u2019s consent management UI/API, which invalidates the grant and revokes all associated refresh tokens.</li> </ol>"},{"location":"revocation-noaccess/#delegation-usage-wip-pending-update","title":"Delegation Usage (WIP pending update)","text":"<p>When exercising the delegated revocation authority, the revocation agent authenticates the user in a manner that meets the set conditions for the requested action, and:</p> <ol> <li>Obtains a DPoP-bound access token from the AS using its refresh token, requesting only the scope that will be requested (revocation action).</li> </ol> <pre><code>POST https://wp.example.com/token\nContent-Type: application/x-www-form-urlencoded\nDPoP: &lt;DPoP_JWT_signed_with_instance_key&gt;\n\ngrant_type=refresh_token&amp;\nrefresh_token=REFRESH_TOKEN_abc123&amp;\nclient_id=revocation_agent_123&amp;\nscope=wallet.revoke.permanent&amp;\nclient_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&amp;\nclient_assertion=&lt;signed_client_assertion_JWT&gt;\n</code></pre> <ol> <li>Calls the WP\u2019s revocation endpoint, presenting the access token, a corresponding DPoP proof, and the conditions that have been met.</li> </ol> <pre><code>POST https://wp.example.com/wallets/wallet_identifier_123/revoke\nAuthorization: DPoP ACCESS_TOKEN_xyz456\nDPoP: &lt;DPoP_JWT_signed_with_same_instance_key&gt;\nContent-Type: application/json\n\n{\n  \"reason\": \"device_loss\"\n  \"conditions\": [\"c_high\"]\n}\n</code></pre> <p>Note that the access token will include the wallet id, e.g., <code>wid</code>, as a custom claim.</p>"},{"location":"revocation-noaccess/#sequence-diagram","title":"Sequence diagram","text":"<pre><code>sequenceDiagram\n  autonumber\n  participant U as WalletOwner\n  participant A as RevocationAgent\n  participant AS as WP_AS\n  participant RS as WP_RS\n\n  Note over U,A: Phase 0: delegation setup (early lifecycle)\n  U-&gt;&gt;A: Agree on agent role and revocation actions\n  A--&gt;&gt;U: Redirect to AS (AuthCode + PKCE)\n\n  U-&gt;&gt;AS: Authenticate and grant scopes for wallet\n  AS--&gt;&gt;U: Authorization code\n  U--&gt;&gt;A: Return code\n\n  A-&gt;&gt;AS: Token request + DPoP proof\n  AS--&gt;&gt;A: Refresh token\n  AS--&gt;&gt;A: DPoP-bound access token (all granted scopes)\n  Note over AS,A: Grant binds agent and scopes\n\n  Note over U,A: Phase 1: delegation use (later, all devices lost)\n  U-&gt;&gt;A: Contact agent and satisfy available condition (c)\n\n  Note over A: Agent chooses scope based on satisfied c\n  A-&gt;&gt;AS: Refresh token + DPoP proof + requested reduced scope\n  AS--&gt;&gt;A: New DPoP-bound access token (reduced scope)\n\n  A-&gt;&gt;RS: Revocation request\n  Note over A,RS: Authorization: DPoP token\n  Note over A,RS: Body: c_id, details\n  RS-&gt;&gt;RS: Validate token and DPoP\n  RS-&gt;&gt;RS: Authorize by scope in access token\n  RS-&gt;&gt;RS: Check c_id is valid for this scope\n  RS--&gt;&gt;A: OK (revoked or suspended)\n  A--&gt;&gt;U: Confirm outcome</code></pre> <p>Notes on the sequence diagram:</p> <p>Revocation actions are represented by defined scopes. Typical scopes are:</p> <ul> <li>Revoke wallet permanently</li> <li>Temporary blocking of wallet</li> </ul> <p>During setup, the revocation agent is granted the scopes this agent is allowed to exercise. The user grants these scopes to the agent under set conditions. Each condition is represented by an identifier c_id. Conditions could look like:</p> <ul> <li>Condition 1 - User has called in and answered a number of control questions</li> <li>Condition 2 - User has authenticated using a national eID</li> </ul> <p>In the initial setup, conditions are assigned to scopes either by explicit agreement or by implicit policies accepted by the user.</p> <p>At revocation time, the user contacts the agent and requests revocation. By doing so, it meets at least one of the defined conditions.</p> <p>The revocation agent selects the scope = revocation action that is consistent with the condition and requests a new access token bound to the scope that is consistent with the satisfied condition.</p> <p>When requesting the revocation, the agent uses the DPoP access token bound to the requested scope and attests to what condition that was satisfied.</p> <p>The resource server handling revocation then checks the claimed condition and that it is consistent with the defined action/scope. If conditions are met, revocation is performed on the wallet associated with the access token.</p> <p>The agent attests condition for audit purposes. If the agent claims a condition that was not satisfied, it can be held accountable.</p> <p>PoP key and refresh token management</p> <p>The time between initial authorization of the agent and a revocation request may be long, up to several years. This diverts from the typical usage of relatively short-lived refresh tokens. We can see several strategies to handle this issue:</p> <ul> <li>Implement long-lived refresh tokens that are valid for the full duration the delegation is valid</li> <li>Enforce that revocation agents renew their refresh tokens periodically</li> </ul> <p>The advantage with the second option here is that this enforces that delegations are up to date and allows the agent to rotate PoP keys on each refresh.</p> <p>Revocation of delegation</p> <p>A key advantage with this setup is that the user can revoke the delegation to authorize an agent to revoke a wallet under agreed conditions at any time. When this is done, the AS will deny further exchange of refresh tokens to new tokens. This is also an argument for implementing a periodic refresh of refresh tokens, as this also serves as a notification to the agent that the authorization to revoke the associated wallet is revoked.</p> <p>Discovery of available revocation agents</p> <p>We assume that revocation agents and wallet providers will act under local agreement, and that client registration is out of scope for this design. A viable option for the local trust setup is, however, to use OpenID federation for trust configuration and to authorize entities to act as revocation agents using trust-marks. Such a setup would also allow wallet holders to discover available revocation agents by using existing enpoint API:s of OpenID federation to list all entities that have been authorized to act in this role.</p>"},{"location":"revocation-noaccess/#appendix-delegated-revocation-and-three-revocation-scenarios","title":"Appendix - Delegated Revocation and Three Revocation Scenarios","text":"<p>This section covers three revocation scenarios. The first is user-initiated, where the user actively authenticates to the Revocation Agent and triggers a revocation request, as previously described.</p> <p>The second scenario occurs when the user does not explicitly revoke the wallet device but instead onboards a new one, possibly unaware that revocation is required. In such cases, if a delegation token exists, the Revocation Agent can detect it, prompt the user, and proceed based on whether the user still controls other devices.</p> <p>The third scenario involves revocation initiated by the Wallet Provider. Although not legally required at the time of writing, TS3 and HLR specify that the user must be notified through a channel other than the wallet device. If the user still has access to their wallet account, the notification can be delivered there. If access is lost, the delegation token, uploaded by the wallet to the user's account, allows the Wallet Provider to inform the designated Revocation Agent, who can then notify the user.</p>"}]}